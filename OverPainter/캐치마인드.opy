settings {
    "main": {
        "modeName": "캐치마인드",
        "description": "제작: 깨꾸/ 화면비율은 16:9여야 합니다./ 최신 코드: 1808X/  https://discord.gg/DKvxxD2bTJ/ 23.5.8"
    },
    "lobby": {
        "enableMatchVoiceChat": true
    },
    "gamemodes": {
        "ffa": {
            "enabledMaps": [
                "workshopChamber"
            ]
        },
        "general": {
            "gamemodeStartTrigger": "immediately"
        }
    },
    "heroes": {
        "allTeams": {
            "dva": {
                "spawnWithoutMech": true
            },
            "hammond": {
                "enableAbility3": false
            },
            "brigitte": {
                "enableMelee": false
            },
            "disabledHeroes": [
                "ramattra",
                "sojourn",
                "junkerQueen",
                "kiriko"
            ]
        }
    },
    "workshop": {
        "최대글자수": 6
    }
}

#Activated extensions

#!extension buffStatusEffects
#!extension energyExplosionEffects
#!extension playMoreEffects
#!extension energyExplosionEffects
#!extension buffStatusEffects


def Sub5():
    @Name "블랙리스트 갱신하는 곳. 인스펙터에서 (X)를 누른 다음 이곳에서 기존 액션을 삭제한 후 붙여넣으세요."
    
    A = null
    B = [vect(-13.845, 12.436, 19.9), vect(-17.825, 12.451, 19.9), vect(-15.805, 14.381, 19.9), vect(-15.835, 10.505, 19.9), vect(-15.657, 15.45, 19.9), vect(-14.3, 9.5, 20), vect(-15.8, 9.5, 20), vect(-17.3, 9.5, 20), vect(-14.3, 8, 20), vect(-15.8, 8, 20), vect(-17.3, 8, 20), vect(-14.3, 6.5, 20), vect(-15.8, 6.5, 20), vect(-17.3, 6.5, 20), vect(-14.3, 5, 20), vect(-15.8, 5, 20), vect(-17.3, 5, 20)]
    C = vect(-15.6, 12.3, 19.9)
    D = [Color.WHITE, Color.BLACK, Color.WHITE, Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.AQUA, Color.BLUE, Color.VIOLET, Color.PURPLE, Color.GRAY]
    F = vect(0, 3, 20)
    G = "ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎㅏㅐㅑㅒㅓㅔㅕㅖㅗ...ㅛㅜ...ㅠㅡ.ㅣ"
    H = [vect(57.057, 44.995, 0), vect(45.769, 44.846, 0), vect(33.744, 45.143, 0), vect(22.604, 45.439, 0), vect(11.321, 45.439, 0), vect(51.713, 57.618, 0), vect(40.128, 57.173, 0), vect(28.845, 57.618, 0), vect(17.111, 58.063, 0), vect(5.977, 57.914, 0), vect(45.775, 70.389, 0), vect(33.893, 70.389, 0), vect(22.604, 70.389, 0), vect(11.47, 70.389, 0), vect(-0.412, 44.698, 0), vect(-12.145, 44.698, 0), vect(-23.28, 44.401, 0), vect(-34.865, 44.698, 0), vect(-46.741, 44.55, 0), vect(-5.609, 58.211, 0), vect(-17.787, 57.914, 0), vect(-28.477, 58.359, 0), vect(-40.507, 58.063, 0), vect(-0.709, 71.873, 0), vect(-11.843, 72.021, 0), vect(-23.428, 72.318, 0), vect(57.057, 70.389, 0), vect(-57.881, 45.439, 0), vect(-53.426, 58.211, 0)]
    I = [[7, 8], [12, 13], [3, 4], [0, 1], [9, 10], 6, 2, 11, 5, 18, 15, 16, 14, 17, 31, 25, 21, [20, 22], [24, 26], 27, 23, 19, 39, 36, 32, 37, 100, 101, 102]
    J = [1, 2, 4, 7, 0, 8, 16, 17, 0, 19, 20, 21, 22, 0, 23, 24, 25, 26, 27]
    K = [[27, 19, 28], [27, 20, 29], [27, 39, 30], [32, 23, 33], [32, 24, 34], [32, 39, 35], [37, 39, 38]]
    L = [[1, 19, 3], [0, 9, 3], [2, 12, 5], [2, 18, 6], [5, 0, 9], [5, 6, 10], [5, 7, 11], [5, 9, 12], [5, 16, 13], [5, 17, 14], [5, 18, 15], [7, 9, 18]]
    M = ""
    N = true
    O = null
    P = null
    Q = false
    T = [30, 120]
    V = 120
    W = 1
    X = 5
    Y = false
    Z = true
    AC = [null, null, null, null, null, null, null, null, null]
    AD = [vect(-141.021, -73, 0), vect(-170.821, -73, 0)]
    AB = []


def Sub9():
    @Name "문제은행. 복사한 후 메모장에 붙여넣고 수정하세요. 글자수에 맞추어서 집어넣되, 하나의 custom string당 128자를 넘을 수 없습니다."
    
    AN = [["간감강개게곰공관귀귤금길김난낫논눈늪달담닭댐덫독돈돌등랩말맛매멍면목몸못묘무문물발밤밥방밭배뱀벌범법벼벽별병볼봄봉북분불붓비빗빚빛산삽새색선성소손솜솥술숯숲신실알암약양연엿옥옷왕용원위윷은음이입잎자잠장재잼절점젓정조족졸좀종죄주죽줄중쥐즙짐집징짚차창책철초", "총춤침칼캔컵코콩퀸키킹탈탑탕터턱털톱통틀틈티팀팁파판팔팥팬펜폐풀피핀학해핵햄향혀형혹깨껌꽃꿀꿈꿩딸땀땅때떡빵뺨뼈뿔싹쌀쑥씨짝둠램떨"], ["겐지리퍼야구고래하마사자기린홈런화투메이장비관우깨꾸방학휴가할인만화영화조조여포라면둘리귀신병원약국의사검사탱커오리기아사람남자여자리본선물대포탱크바람나무숫자철학타조토르헐크갈치참치생일국수잔치제사사고키스커플스님목사신부종교학교학원야자버스택시천사", "웹툰동생천재바보원빈마더혜자창렬현빈우산수지래퍼킹콩롤린틀니감옥족발보쌈클럽소주맥주양주와인종이부츠신발팔찌발찌당구축구배구피구농구볼링수영유도주먹바닥한조애쉬과학단군신라백제고려조선늑대염소이끼벌레우산자연풍경위인선물생선사람사랑하트수학미분적분백제신라", "조선고려김구죄수감옥탈옥삼성엘지한화엔씨카트마트쇼핑해장국밥멸치날치꽁치참치스킬평타마차버스택시공포유령네팔부산서울광주군대군인하사중사천안연어횟집갈치푸들샴푸조로루피상디나미로빈사과포도애쉬뉴턴악보골초국수초밥족발보쌈콜라장갑초커수지호수성냥왕관테란저그", "개미벌레바퀴제사심영고자수박호박오이배추상추깻잎고수아빠교수뚱이양말짱구파이전기공기펭수참외밥통밥솥아리걸레수건당구수갑밧줄무릎어깨이마눈썹다리팔뚝손목열쇠대문펭귄요정딱풀연필술집새집칼집고집개집침실마당연근치킨호텔모텔온천목욕금고군견기계과녁그네그늘금니", "검도가로가루골룸공룡구름그릇기름기린공항교회농부대추모기매미무릎모자뭉크번개바늘바다꼬리뽀뽀씨름짝눈해킹해태흉터해마헬멧폭포에코파라엘사커비샌즈질럿마린케장볼짤궁수도적손톱발톱무좀콩팥철봉용암지건먹방노예오목책상의자뉴스신문멜빵피클문명일본중국엄크레옹화분", "탈모철권도끼추락날개쇄골복근왕자공주여왕주인설구자폭포화용검집결융화방벽초월성냥팩맨채연장어낑깡꼬막전복홍합홍수권투봉투금발아나"], ["메르시오리사무야호박명수고래밥홈런볼신라면아리수견과류마이콜도우너노래방송하나피카츄캐터피야도란근육몬괴력몬라이터마법사마술사유튜브트위치트위터화장실개인기검문소고라니하늘소풍뎅이메뚜기마스터데드풀고등어굴렁쇠네이버도토리다람쥐햄스터고양이호랑이도깨비", "송충이파스타류승범김태희꼬부기백종원야스오아이유조보아김재원고구려노가다황정민류승룡차승원유해진투석기하바나버거킹대학교신세계꼴뚜기오징어술고래소방관동자승감스트무지개비너스탄지로네즈코비틀즈탈레반기독교무슬림홍진호임요환하세기야스오면도기립스틱개나리", "도롱뇽도마뱀날파리갤럭시노트북카지노골리앗트랙터경운기밥로스아줌마나루토호카게카카시손오공사오정저팔계청새치돛단배정크랫레킹볼파르시컴퓨터키보드마우스인터넷복숭아코코넛물음표느낌표짝사랑골키퍼시미켄피아노맥크리마피아파스타떡볶이나뭇잎장갑차눈동자꽹가리", "타이어선넘네엉덩국이병헌테슬라배트맨슈퍼맨여왕벌예초기기모띠머리띠페이커운동화캔버스콤파스각도기싸인펜뚝배기비빔밥굳건이코로나마스크선생님징징이엄준식훈발놈원펀맨뽀로로뿡뿡이물티슈솥뚜껑삼겹살구미호닭싸움양꼬치사투리러시아자물쇠스위스멕시코스페인지우개", "지우개세탁기여드름구루마구렁이그래프계란빵가마솥고물상고무신가물치거북선경찰서개헤엄나침반나이키두개골돌고래독거미돈가스돋보기도토리미나리물갈퀴멧돼지벽난로배두나사랑니슬리퍼솔방울솜사탕소시지색소폰수수깡샤워기색안경스프링스피커산딸기솥뚜껑야구공어금니", "아가미용가리오른팔아메바얼음땡원피스아파트애꾸눈지렛대이세계지팡이쥐꼬리측우기추어탕설렁탕캥거루콩기름커플링코뿔소토끼풀홍두깨핵무기하이킥하이힐히틀러쪽가위호날두쌍둥이루시우모이라솜브라시그마윈스턴자리야젠야타노진구깐풍기눈사람금태양엉덩국기생충연가시", "사마귀손가락발가락저격수티셔츠츄리닝타노스연양갱치토스참이슬홍길동여의주펠리칸하정우라디오에어팟이어폰아이폰바선생전깃줄전봇대애완견거북이신기루재활용건전지리모컨장례식노래방제우스코코볼눈싸움진달래사우론샤프심안중근미호크대머리아구몬파이리제노스가로우", "보로스돌도끼메테오정강이팔꿈치가오리개구리두꺼비메가맨깔깔이너구리고라니자전거햄버거사륜안오타쿠워크샵신호등칼국수그라탕불장난막대기낚싯대레모나핫식스레드불박카스"], ["오버워치둠피스트숨바꼭질술래잡기더위사냥대한민국일석이조시메트라원령공주아프리카어벤저스블랙펜서아이언맨내부자들고등래퍼전자발찌나폴레옹호크아이검은사막어몽어스임포스터하이에나리장타워일리오스맥도날드김밥천국곰돌이푸이스라엘디스코드브리기테토르비욘로드호그", "바티스트파인애플민트초코호두나무사과나무짜파게티스파게티순대국밥야인시대네토라레김치전사어버이날카네이션인어공주백설공주치코리타바퀴벌레사이타마사도세자가지치기지뢰찾기가위치기군고구마구레나룻계란말이곱슬머리고슴도치동그라미달마시안두꺼비집미끄럼틀미꾸라지", "세종대왕이쑤시개제비뽑기주지스님토네이도테트리스포크레인해오라기바스티온도라에몽겨울왕국언더테일다크소울스카이림매직클로하스스톤네일아트산와머니와이셔츠범죄도시삼장법사카레이서포트리스오아시스비트코인크로아상멜빵바지롯데타워육삼빌딩타코야키갸라도스교통사고", "겨드랑이중력자탄펄스폭탄죽음의꽃대지분쇄지진강타용의일격이구아나카멜레온톱니바퀴오토바이에버랜드횡단보도라이온킹"], ["캐치마인드오스트리아마이클잭슨마이클조던라인하르트ㅋㅋㄹㅃㅃ포켓몬스터제프카플란블랙위도우살인의추억쇼미더머니콜오브듀티버락오바마귀멸의칼날스티브잡스아이헨발데서울대학교진격의거인명탐정코난마이클조던베어그릴스사쿠야유아아오이소라엎드려뻗쳐길로틴초크", "파워레인저일론머스크다크나이트스파이더맨엿보기구멍트로피카나아메리카노전자레인지방탄소년단아이아몬드미니스커트스노우보드성모마리아산타클로스야구방망이양들의침묵우사인볼트아이스크림오이소박이진공청소기장수풍뎅이장수하늘소전자레인지증조할머니찰리채플린", "콘택트렌즈패스트푸드피타고라스개척파쿠르하프라이프터미네이터스크린골프코인노래방구일일테러반지의제왕웨딩드레스로봇청소기파멸의일격전술조준경나노강화제카트라이더클레멘타인"], ["배틀그라운드캡틴아메리카프리미어리그우즈베키스탄이웃집토토로스타크래프트브레이브걸스메이플스토리도널드트럼프동백꽃필무렵성냥팔이소녀짱구는못말려다이너마이트롤러스케이트뫼비우스의띠비디오테이프아이공룡둘리위도우메이커트리케라톱스자유의여신상피카츄돈까스", "버스커버스커오즈의마법사카드캡터체리에어프라이어황야의무법자초고열용광로만화경사륜안봉골레파스타포카리스웨트"], ["꼬꼬마텔레토비상하이드래곤즈그놈은멋있었다리그오브레전드스티븐스필버그솔저세븐티식스시베리안허스키스테인드글라스라스트오브어스당긋빳다죠쉬바아이엠아이언맨티라노사우루스킹오브파이터즈스트리트파이터"], ["갈릴레오갈릴레이사랑은아무나하나하울의움직이는성카운터스트라이크좁아터진오버워치개구리중사케로로네모바지스폰지밥킬리만자로의표범동굴에서살아남기브라키오사우루스크레이지아케이드"]]


def Sub6():
    @Name "추방단어"
    
    AE = []
    AE.append("노무")
    AE.append("홍어")
    AE.append("운지")
    AE.append("무현")
    AE.append("응디")


def Sub7():
    @Name "금지단어"
    
    AF = []
    AF.append("똥")
    AF.append("응가")
    AF.append("자지")
    AF.append("보지")
    AF.append("*")
    AF.append("*")
    AF.append("씹")
    AF.append("니얼굴")
    AF.append("설사")


rule "기본 변수":
    disableInspector()
    disableGamemodeCompletion()
    disableAnnouncer()
    disableMusic()
    Sub5()
    Sub6()
    Sub7()
    N = 0
    O = []
    Q = createWorkshopSetting(bool, "기본설정", "맞히면 종료", false, 2)
    R = 0
    T = [createWorkshopSetting(int[20:60], "기본설정", "문제 입력시간", 30, 10), createWorkshopSetting(int[60:300], "기본설정", "맞히는 시간", 120, 11)]
    U = 0
    Z = createWorkshopSetting(enum["그린 사람", "다음 순서(출제자가 그리기)", "문제은행"], "기본설정", "출제", 0, 1)
    X = 10 if Z == 2 else createWorkshopSetting(int[2:8], "기본설정", "최대글자수", 5, 12)
    AN = []
    Y = createWorkshopSetting(bool, "기본설정", "초성으로 맞히기", false, 3)
    AA = createWorkshopSetting(enum["번호순", "맞힌 사람 중 무작위", "처음 맞힌 사람", "무작위"], "기본설정", "순서", 0, 0)
    AC = []
    AH = createWorkshopSetting(bool, "기본설정", "라운드", true, -2)
    AI = createWorkshopSetting(int[10:50], "기본설정", "라운드 수", 20, -1)
    AJ = 1
    AS = createWorkshopSetting(bool, "기본설정", "번호 섞기", true, 4)
    setMatchTime(5)
    waitUntil(isGameInProgress() and AC, 99999)
    if Z == 2:
        Sub9()
        AO = 0
        AU = []
        for AP in range(8):
            for AQ in range(len(AN[AP])):
                AO += strLen(AN[AP][AQ]) / (AP + 1)
                AU.append([[AO, AP, AQ]])
        Sub13()
    else:
        V = T[0]
        P = AC[0]
        P.T = true
        P.AI = true
    setMatchTime(V)
    for AQ in range(4):
        createBeam(AC, Beam.GOOD, vect(-13 if AQ < 2 else 13, 15 + (-8 if AQ < 2 else 3.9), 19.9), vect(13 if AQ % 2 else -13, 15 + (-8 if AQ % 2 else 3.9), 19.9), Color.GREEN, EffectReeval.VISIBILITY)
    for AQ in range(6, len(B)):
        createInWorldText([player for player in A if getMatchTime()], "■", B[AQ] + Vector.DOWN * 0.5, 5, Clip.NONE, WorldTextReeval.VISIBILITY, D[AQ - 5], SpecVisibility.DEFAULT)
    AQ = false
    createInWorldText(A, "□", B[5] + Vector.DOWN * 0.5, 5, Clip.NONE, WorldTextReeval.VISIBILITY_AND_COLOR, false if A.G or not getMatchTime() else Color.WHITE, SpecVisibility.DEFAULT)
    createInWorldText(A, iconString(Icon.TRASHCAN), B[5] + Vector.DOWN * 0.35, 2.5, Clip.NONE, WorldTextReeval.VISIBILITY_AND_COLOR, Color.WHITE if A.G and getMatchTime() else false, SpecVisibility.DEFAULT)
    createEffect([player for player in A if not player.isHoldingButton(Button.ABILITY_1) and (player.G or player.isHoldingButton(Button.SECONDARY_FIRE))], Effect.GOOD_AURA, Color.WHITE, A.A - vect(0, 0, 0.1), A.M, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
    createInWorldText([i for i in localPlayer if localPlayer.T], "{0}{1}".format(localPlayer.Z, localPlayer.O.last()), vect(0, 6.2, 20), 2.5, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.BLUE, SpecVisibility.DEFAULT)
    createInWorldText([i for i in localPlayer if localPlayer.T], "ㅃ ㅉ ㄸ ㄲ ㅆ ㅛ ㅕ ㅑ ㅒ ㅖ ←\r\n  ㅁ ㄴ ㅇ ㄹ ㅎ ㅗ ㅓ ㅏ ㅣ <┘\r\n↑ ㅋ ㅌ ㅊ ㅍ ㅠ ㅜ ㅡ" if localPlayer.V else "ㅂ ㅈ ㄷ ㄱ ㅅ ㅛ ㅕ ㅑ ㅐ ㅔ ←\r\n  ㅁ ㄴ ㅇ ㄹ ㅎ ㅗ ㅓ ㅏ ㅣ <┘\r\n↑ ㅋ ㅌ ㅊ ㅍ ㅠ ㅜ ㅡ", vect(0, 3, 20), 3, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.WHITE, SpecVisibility.NEVER)
    createInWorldText([player for player in A if getMatchTime()], "◀{0}                 {1}▶".format(buttonString(Button.ULTIMATE), buttonString(Button.ABILITY_2)), vect(-15.8, 12.1, 20), 2, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.BLUE, SpecVisibility.DEFAULT)
    createInWorldText([player for player in A if getMatchTime()], "▲\r\n{0}\r\n\r\n\r\n{1}\r\n▼".format(buttonString(Button.RELOAD), buttonString(Button.MELEE)), vect(-15.8, 10.6, 20), 2, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.BLUE, SpecVisibility.DEFAULT)
    createInWorldText([player for player in P if not N], "무엇을 그릴지 입력하세요!(최대 {0}글자)".format(X), vect(0, 7.5, 20), 2, Clip.NONE, WorldTextReeval.VISIBILITY, Color.BLUE, SpecVisibility.DEFAULT)
    createInWorldText([player for player in A if getMatchTime()], "포기", vect(-15.7, 15, 20), 3, Clip.NONE, WorldTextReeval.VISIBILITY, Color.WHITE, SpecVisibility.DEFAULT)
    createInWorldText(localPlayer, " 커서 감도 조절 \r\n ◀               ▶" if localPlayer.AI else M, vect(-15.7, 17, 20), 2, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.WHITE, SpecVisibility.DEFAULT)
    createInWorldText(localPlayer, "{0}%".format(localPlayer.AF) if localPlayer.AI else M, vect(-15.7, 16.9, 20), 2, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.WHITE, SpecVisibility.DEFAULT)
    createProgressBarInWorldText([player for player in AC if getMatchTime() and A], ((getNumberOfEntityIds() - 6) / 250) * 100, null, vect(0, 18.45, 20), 1.2, Clip.NONE, [Color.GREEN, Color.RED][getNumberOfEntityIds() > 200], Color.WHITE, ProgressWorldTextReeval.VISIBILITY_VALUES_AND_COLOR, SpecVisibility.DEFAULT)
    createInWorldText([player for player in AC if getMatchTime() and A.AI], "그리기 제한 {0}/250".format(getNumberOfEntityIds() - 6), vect(8.4, 19, 20), 1.8, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.WHITE, SpecVisibility.DEFAULT)
    if Y:
        createInWorldText(N, "※초성만 입력해도 정답처리됩니다", vect(8.2, 18.3, 20), 1.2, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.BLUE, SpecVisibility.DEFAULT)
    if AH:
        createInWorldText(AC, "{0}/{1} 라운드".format(AJ, AI), vect(-11.7, 18.5, 20), 2, Clip.NONE, WorldTextReeval.VISIBILITY_AND_STRING, Color.GREEN, SpecVisibility.DEFAULT)
    createInWorldText([i for i in localPlayer if localPlayer.AI], "▶", updateEveryTick(vect(-0.27, 9.3, 20) + 0.1 * (vect(localPlayer.getHorizontalFacingAngle(), -1 * localPlayer.getVerticalFacingAngle(), 0))), 2.5, Clip.NONE, WorldTextReeval.VISIBILITY_POSITION_STRING_AND_COLOR, localPlayer.D, SpecVisibility.DEFAULT)
    progressBarHud([player for player in AC if getMatchTime()], 100 * (getMatchTime() / V), "{0}{1}".format(A if N else P, (" 님! [{0}]{1} 표현하세요!".format(R, AT) if localPlayer.S else " 님의 표현이 끝날 때까지 구경하세요! (정답: {0})".format(R) if localPlayer == P else ": 이것은 무엇일까요?") if N else " 님이 무엇을 그릴지 정하고 있습니다."), HudPosition.TOP, 1, [Color.RED, Color.ORANGE, Color.GREEN][floor(getMatchTime() / V * 3)], Color.GREEN, ProgressHudReeval.VISIBILITY_VALUES_AND_COLOR, SpecVisibility.DEFAULT)
    hudText(AC, (" 힌트:{0} ".format(S) if getMatchTime() else " 정답: {0} ".format(R)) if N else M, "　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\r\n\r\n", null, HudPosition.LEFT, 2, Color.BLUE, Color.WHITE, Color.WHITE, HudReeval.VISIBILITY_AND_STRING, SpecVisibility.DEFAULT)
    hudSubheader(AC.exclude(hostPlayer), " ", HudPosition.LEFT, 3.1, Color.WHITE, HudReeval.VISIBILITY, SpecVisibility.DEFAULT)
    hudSubtext(AC, "제작: 깨꾸\r\n코드: 1808X", HudPosition.RIGHT, 0.4, Color.WHITE, HudReeval.VISIBILITY, SpecVisibility.DEFAULT)
    createInWorldText([player for player in A if (A.isHoldingButton(Button.SECONDARY_FIRE) or A.G) and A.isHoldingButton(Button.ABILITY_1)], iconString(Icon.RECYCLE), A.A - vect(0, 1.1, 0), 4, Clip.NONE, WorldTextReeval.VISIBILITY_AND_POSITION, Color.WHITE, SpecVisibility.DEFAULT)
    wait(0)
    pauseMatchTime()
    waitUntil(len(AC) > 1, 99999)
    unpauseMatchTime()


rule "한글1":
    E = [["가각갂갃간갅갆갇갈갉갊갋갌갍갎갏감갑값갓갔강갖갗갘같갚갛개객갞갟갠갡갢갣갤갥갦갧갨갩갪갫갬갭갮갯갰갱갲갳갴갵갶갷갸갹갺갻갼갽갾갿걀걁걂걃걄걅걆걇걈걉걊걋걌걍걎걏걐걑걒걓걔걕걖걗걘걙걚걛걜걝걞걟걠걡걢걣걤걥걦걧걨걩걪걫걬걭걮걯", "거걱걲걳건걵걶걷걸걹걺걻걼걽걾걿검겁겂것겄겅겆겇겈겉겊겋게겍겎겏겐겑겒겓겔겕겖겗겘겙겚겛겜겝겞겟겠겡겢겣겤겥겦겧겨격겪겫견겭겮겯결겱겲겳겴겵겶겷겸겹겺겻겼경겾겿곀곁곂곃계곅곆곇곈곉곊곋곌곍곎곏곐곑곒곓곔곕곖곗곘곙곚곛곜곝곞곟", "고곡곢곣곤곥곦곧골곩곪곫곬곭곮곯곰곱곲곳곴공곶곷곸곹곺곻과곽곾곿관괁괂괃괄괅괆괇괈괉괊괋괌괍괎괏괐광괒괓괔괕괖괗괘괙괚괛괜괝괞괟괠괡괢괣괤괥괦괧괨괩괪괫괬괭괮괯괰괱괲괳괴괵괶괷괸괹괺괻괼괽괾괿굀굁굂굃굄굅굆굇굈굉굊굋굌굍굎굏", "교굑굒굓굔굕굖굗굘굙굚굛굜굝굞굟굠굡굢굣굤굥굦굧굨굩굪굫구국굮굯군굱굲굳굴굵굶굷굸굹굺굻굼굽굾굿궀궁궂궃궄궅궆궇궈궉궊궋권궍궎궏궐궑궒궓궔궕궖궗궘궙궚궛궜궝궞궟궠궡궢궣궤궥궦궧궨궩궪궫궬궭궮궯궰궱궲궳궴궵궶궷궸궹궺궻궼궽궾궿", "귀귁귂귃귄귅귆귇귈귉귊귋귌귍귎귏귐귑귒귓귔귕귖귗귘귙귚귛규귝귞귟균귡귢귣귤귥귦귧귨귩귪귫귬귭귮귯귰귱귲귳귴귵귶귷그극귺귻근귽귾귿글긁긂긃긄긅긆긇금급긊긋긌긍긎긏긐긑긒긓긔긕긖긗긘긙긚긛긜긝긞긟긠긡긢긣긤긥긦긧긨긩긪긫긬긭긮긯", "기긱긲긳긴긵긶긷길긹긺긻긼긽긾긿김깁깂깃깄깅깆깇깈깉깊깋"], ["까깍깎깏깐깑깒깓깔깕깖깗깘깙깚깛깜깝깞깟깠깡깢깣깤깥깦깧깨깩깪깫깬깭깮깯깰깱깲깳깴깵깶깷깸깹깺깻깼깽깾깿꺀꺁꺂꺃꺄꺅꺆꺇꺈꺉꺊꺋꺌꺍꺎꺏꺐꺑꺒꺓꺔꺕꺖꺗꺘꺙꺚꺛꺜꺝꺞꺟꺠꺡꺢꺣꺤꺥꺦꺧꺨꺩꺪꺫꺬꺭꺮꺯꺰꺱꺲꺳꺴꺵꺶꺷꺸꺹꺺꺻", "꺼꺽꺾꺿껀껁껂껃껄껅껆껇껈껉껊껋껌껍껎껏껐껑껒껓껔껕껖껗께껙껚껛껜껝껞껟껠껡껢껣껤껥껦껧껨껩껪껫껬껭껮껯껰껱껲껳껴껵껶껷껸껹껺껻껼껽껾껿꼀꼁꼂꼃꼄꼅꼆꼇꼈꼉꼊꼋꼌꼍꼎꼏꼐꼑꼒꼓꼔꼕꼖꼗꼘꼙꼚꼛꼜꼝꼞꼟꼠꼡꼢꼣꼤꼥꼦꼧꼨꼩꼪꼫", "꼬꼭꼮꼯꼰꼱꼲꼳꼴꼵꼶꼷꼸꼹꼺꼻꼼꼽꼾꼿꽀꽁꽂꽃꽄꽅꽆꽇꽈꽉꽊꽋꽌꽍꽎꽏꽐꽑꽒꽓꽔꽕꽖꽗꽘꽙꽚꽛꽜꽝꽞꽟꽠꽡꽢꽣꽤꽥꽦꽧꽨꽩꽪꽫꽬꽭꽮꽯꽰꽱꽲꽳꽴꽵꽶꽷꽸꽹꽺꽻꽼꽽꽾꽿꾀꾁꾂꾃꾄꾅꾆꾇꾈꾉꾊꾋꾌꾍꾎꾏꾐꾑꾒꾓꾔꾕꾖꾗꾘꾙꾚꾛", "꾜꾝꾞꾟꾠꾡꾢꾣꾤꾥꾦꾧꾨꾩꾪꾫꾬꾭꾮꾯꾰꾱꾲꾳꾴꾵꾶꾷꾸꾹꾺꾻꾼꾽꾾꾿꿀꿁꿂꿃꿄꿅꿆꿇꿈꿉꿊꿋꿌꿍꿎꿏꿐꿑꿒꿓꿔꿕꿖꿗꿘꿙꿚꿛꿜꿝꿞꿟꿠꿡꿢꿣꿤꿥꿦꿧꿨꿩꿪꿫꿬꿭꿮꿯꿰꿱꿲꿳꿴꿵꿶꿷꿸꿹꿺꿻꿼꿽꿾꿿뀀뀁뀂뀃뀄뀅뀆뀇뀈뀉뀊뀋", "뀌뀍뀎뀏뀐뀑뀒뀓뀔뀕뀖뀗뀘뀙뀚뀛뀜뀝뀞뀟뀠뀡뀢뀣뀤뀥뀦뀧뀨뀩뀪뀫뀬뀭뀮뀯뀰뀱뀲뀳뀴뀵뀶뀷뀸뀹뀺뀻뀼뀽뀾뀿끀끁끂끃끄끅끆끇끈끉끊끋끌끍끎끏끐끑끒끓끔끕끖끗끘끙끚끛끜끝끞끟끠끡끢끣끤끥끦끧끨끩끪끫끬끭끮끯끰끱끲끳끴끵끶끷끸끹끺끻", "끼끽끾끿낀낁낂낃낄낅낆낇낈낉낊낋낌낍낎낏낐낑낒낓낔낕낖낗"], ["나낙낚낛난낝낞낟날낡낢낣낤낥낦낧남납낪낫났낭낮낯낰낱낲낳내낵낶낷낸낹낺낻낼낽낾낿냀냁냂냃냄냅냆냇냈냉냊냋냌냍냎냏냐냑냒냓냔냕냖냗냘냙냚냛냜냝냞냟냠냡냢냣냤냥냦냧냨냩냪냫냬냭냮냯냰냱냲냳냴냵냶냷냸냹냺냻냼냽냾냿넀넁넂넃넄넅넆넇", "너넉넊넋넌넍넎넏널넑넒넓넔넕넖넗넘넙넚넛넜넝넞넟넠넡넢넣네넥넦넧넨넩넪넫넬넭넮넯넰넱넲넳넴넵넶넷넸넹넺넻넼넽넾넿녀녁녂녃년녅녆녇녈녉녊녋녌녍녎녏념녑녒녓녔녕녖녗녘녙녚녛녜녝녞녟녠녡녢녣녤녥녦녧녨녩녪녫녬녭녮녯녰녱녲녳녴녵녶녷", "노녹녺녻논녽녾녿놀놁놂놃놄놅놆놇놈놉놊놋놌농놎놏놐놑높놓놔놕놖놗놘놙놚놛놜놝놞놟놠놡놢놣놤놥놦놧놨놩놪놫놬놭놮놯놰놱놲놳놴놵놶놷놸놹놺놻놼놽놾놿뇀뇁뇂뇃뇄뇅뇆뇇뇈뇉뇊뇋뇌뇍뇎뇏뇐뇑뇒뇓뇔뇕뇖뇗뇘뇙뇚뇛뇜뇝뇞뇟뇠뇡뇢뇣뇤뇥뇦뇧", "뇨뇩뇪뇫뇬뇭뇮뇯뇰뇱뇲뇳뇴뇵뇶뇷뇸뇹뇺뇻뇼뇽뇾뇿눀눁눂눃누눅눆눇눈눉눊눋눌눍눎눏눐눑눒눓눔눕눖눗눘눙눚눛눜눝눞눟눠눡눢눣눤눥눦눧눨눩눪눫눬눭눮눯눰눱눲눳눴눵눶눷눸눹눺눻눼눽눾눿뉀뉁뉂뉃뉄뉅뉆뉇뉈뉉뉊뉋뉌뉍뉎뉏뉐뉑뉒뉓뉔뉕뉖뉗", "뉘뉙뉚뉛뉜뉝뉞뉟뉠뉡뉢뉣뉤뉥뉦뉧뉨뉩뉪뉫뉬뉭뉮뉯뉰뉱뉲뉳뉴뉵뉶뉷뉸뉹뉺뉻뉼뉽뉾뉿늀늁늂늃늄늅늆늇늈늉늊늋늌늍늎늏느늑늒늓는늕늖늗늘늙늚늛늜늝늞늟늠늡늢늣늤능늦늧늨늩늪늫늬늭늮늯늰늱늲늳늴늵늶늷늸늹늺늻늼늽늾늿닀닁닂닃닄닅닆닇", "니닉닊닋닌닍닎닏닐닑닒닓닔닕닖닗님닙닚닛닜닝닞닟닠닡닢닣"], ["다닥닦닧단닩닪닫달닭닮닯닰닱닲닳담답닶닷닸당닺닻닼닽닾닿대댁댂댃댄댅댆댇댈댉댊댋댌댍댎댏댐댑댒댓댔댕댖댗댘댙댚댛댜댝댞댟댠댡댢댣댤댥댦댧댨댩댪댫댬댭댮댯댰댱댲댳댴댵댶댷댸댹댺댻댼댽댾댿덀덁덂덃덄덅덆덇덈덉덊덋덌덍덎덏덐덑덒덓", "더덕덖덗던덙덚덛덜덝덞덟덠덡덢덣덤덥덦덧덨덩덪덫덬덭덮덯데덱덲덳덴덵덶덷델덹덺덻덼덽덾덿뎀뎁뎂뎃뎄뎅뎆뎇뎈뎉뎊뎋뎌뎍뎎뎏뎐뎑뎒뎓뎔뎕뎖뎗뎘뎙뎚뎛뎜뎝뎞뎟뎠뎡뎢뎣뎤뎥뎦뎧뎨뎩뎪뎫뎬뎭뎮뎯뎰뎱뎲뎳뎴뎵뎶뎷뎸뎹뎺뎻뎼뎽뎾뎿돀돁돂돃", "도독돆돇돈돉돊돋돌돍돎돏돐돑돒돓돔돕돖돗돘동돚돛돜돝돞돟돠돡돢돣돤돥돦돧돨돩돪돫돬돭돮돯돰돱돲돳돴돵돶돷돸돹돺돻돼돽돾돿됀됁됂됃됄됅됆됇됈됉됊됋됌됍됎됏됐됑됒됓됔됕됖됗되됙됚됛된됝됞됟될됡됢됣됤됥됦됧됨됩됪됫됬됭됮됯됰됱됲됳", "됴됵됶됷됸됹됺됻됼됽됾됿둀둁둂둃둄둅둆둇둈둉둊둋둌둍둎둏두둑둒둓둔둕둖둗둘둙둚둛둜둝둞둟둠둡둢둣둤둥둦둧둨둩둪둫둬둭둮둯둰둱둲둳둴둵둶둷둸둹둺둻둼둽둾둿뒀뒁뒂뒃뒄뒅뒆뒇뒈뒉뒊뒋뒌뒍뒎뒏뒐뒑뒒뒓뒔뒕뒖뒗뒘뒙뒚뒛뒜뒝뒞뒟뒠뒡뒢뒣", "뒤뒥뒦뒧뒨뒩뒪뒫뒬뒭뒮뒯뒰뒱뒲뒳뒴뒵뒶뒷뒸뒹뒺뒻뒼뒽뒾뒿듀듁듂듃듄듅듆듇듈듉듊듋듌듍듎듏듐듑듒듓듔듕듖듗듘듙듚듛드득듞듟든듡듢듣들듥듦듧듨듩듪듫듬듭듮듯듰등듲듳듴듵듶듷듸듹듺듻듼듽듾듿딀딁딂딃딄딅딆딇딈딉딊딋딌딍딎딏딐딑딒딓", "디딕딖딗딘딙딚딛딜딝딞딟딠딡딢딣딤딥딦딧딨딩딪딫딬딭딮딯"], ["따딱딲딳딴딵딶딷딸딹딺딻딼딽딾딿땀땁땂땃땄땅땆땇땈땉땊땋때땍땎땏땐땑땒땓땔땕땖땗땘땙땚땛땜땝땞땟땠땡땢땣땤땥땦땧땨땩땪땫땬땭땮땯땰땱땲땳땴땵땶땷땸땹땺땻땼땽땾땿떀떁떂떃떄떅떆떇떈떉떊떋떌떍떎떏떐떑떒떓떔떕떖떗떘떙떚떛떜떝떞떟", "떠떡떢떣떤떥떦떧떨떩떪떫떬떭떮떯떰떱떲떳떴떵떶떷떸떹떺떻떼떽떾떿뗀뗁뗂뗃뗄뗅뗆뗇뗈뗉뗊뗋뗌뗍뗎뗏뗐뗑뗒뗓뗔뗕뗖뗗뗘뗙뗚뗛뗜뗝뗞뗟뗠뗡뗢뗣뗤뗥뗦뗧뗨뗩뗪뗫뗬뗭뗮뗯뗰뗱뗲뗳뗴뗵뗶뗷뗸뗹뗺뗻뗼뗽뗾뗿똀똁똂똃똄똅똆똇똈똉똊똋똌똍똎똏", "또똑똒똓똔똕똖똗똘똙똚똛똜똝똞똟똠똡똢똣똤똥똦똧똨똩똪똫똬똭똮똯똰똱똲똳똴똵똶똷똸똹똺똻똼똽똾똿뙀뙁뙂뙃뙄뙅뙆뙇뙈뙉뙊뙋뙌뙍뙎뙏뙐뙑뙒뙓뙔뙕뙖뙗뙘뙙뙚뙛뙜뙝뙞뙟뙠뙡뙢뙣뙤뙥뙦뙧뙨뙩뙪뙫뙬뙭뙮뙯뙰뙱뙲뙳뙴뙵뙶뙷뙸뙹뙺뙻뙼뙽뙾뙿", "뚀뚁뚂뚃뚄뚅뚆뚇뚈뚉뚊뚋뚌뚍뚎뚏뚐뚑뚒뚓뚔뚕뚖뚗뚘뚙뚚뚛뚜뚝뚞뚟뚠뚡뚢뚣뚤뚥뚦뚧뚨뚩뚪뚫뚬뚭뚮뚯뚰뚱뚲뚳뚴뚵뚶뚷뚸뚹뚺뚻뚼뚽뚾뚿뛀뛁뛂뛃뛄뛅뛆뛇뛈뛉뛊뛋뛌뛍뛎뛏뛐뛑뛒뛓뛔뛕뛖뛗뛘뛙뛚뛛뛜뛝뛞뛟뛠뛡뛢뛣뛤뛥뛦뛧뛨뛩뛪뛫뛬뛭뛮뛯", "뛰뛱뛲뛳뛴뛵뛶뛷뛸뛹뛺뛻뛼뛽뛾뛿뜀뜁뜂뜃뜄뜅뜆뜇뜈뜉뜊뜋뜌뜍뜎뜏뜐뜑뜒뜓뜔뜕뜖뜗뜘뜙뜚뜛뜜뜝뜞뜟뜠뜡뜢뜣뜤뜥뜦뜧뜨뜩뜪뜫뜬뜭뜮뜯뜰뜱뜲뜳뜴뜵뜶뜷뜸뜹뜺뜻뜼뜽뜾뜿띀띁띂띃띄띅띆띇띈띉띊띋띌띍띎띏띐띑띒띓띔띕띖띗띘띙띚띛띜띝띞띟", "띠띡띢띣띤띥띦띧띨띩띪띫띬띭띮띯띰띱띲띳띴띵띶띷띸띹띺띻"], ["라락띾띿란랁랂랃랄랅랆랇랈랉랊랋람랍랎랏랐랑랒랓랔랕랖랗래랙랚랛랜랝랞랟랠랡랢랣랤랥랦랧램랩랪랫랬랭랮랯랰랱랲랳랴략랶랷랸랹랺랻랼랽랾랿럀럁럂럃럄럅럆럇럈량럊럋럌럍럎럏럐럑럒럓럔럕럖럗럘럙럚럛럜럝럞럟럠럡럢럣럤럥럦럧럨럩럪럫", "러럭럮럯런럱럲럳럴럵럶럷럸럹럺럻럼럽럾럿렀렁렂렃렄렅렆렇레렉렊렋렌렍렎렏렐렑렒렓렔렕렖렗렘렙렚렛렜렝렞렟렠렡렢렣려력렦렧련렩렪렫렬렭렮렯렰렱렲렳렴렵렶렷렸령렺렻렼렽렾렿례롁롂롃롄롅롆롇롈롉롊롋롌롍롎롏롐롑롒롓롔롕롖롗롘롙롚롛", "로록롞롟론롡롢롣롤롥롦롧롨롩롪롫롬롭롮롯롰롱롲롳롴롵롶롷롸롹롺롻롼롽롾롿뢀뢁뢂뢃뢄뢅뢆뢇뢈뢉뢊뢋뢌뢍뢎뢏뢐뢑뢒뢓뢔뢕뢖뢗뢘뢙뢚뢛뢜뢝뢞뢟뢠뢡뢢뢣뢤뢥뢦뢧뢨뢩뢪뢫뢬뢭뢮뢯뢰뢱뢲뢳뢴뢵뢶뢷뢸뢹뢺뢻뢼뢽뢾뢿룀룁룂룃룄룅룆룇룈룉룊룋", "료룍룎룏룐룑룒룓룔룕룖룗룘룙룚룛룜룝룞룟룠룡룢룣룤룥룦룧루룩룪룫룬룭룮룯룰룱룲룳룴룵룶룷룸룹룺룻룼룽룾룿뤀뤁뤂뤃뤄뤅뤆뤇뤈뤉뤊뤋뤌뤍뤎뤏뤐뤑뤒뤓뤔뤕뤖뤗뤘뤙뤚뤛뤜뤝뤞뤟뤠뤡뤢뤣뤤뤥뤦뤧뤨뤩뤪뤫뤬뤭뤮뤯뤰뤱뤲뤳뤴뤵뤶뤷뤸뤹뤺뤻", "뤼뤽뤾뤿륀륁륂륃륄륅륆륇륈륉륊륋륌륍륎륏륐륑륒륓륔륕륖륗류륙륚륛륜륝륞륟률륡륢륣륤륥륦륧륨륩륪륫륬륭륮륯륰륱륲륳르륵륶륷른륹륺륻를륽륾륿릀릁릂릃름릅릆릇릈릉릊릋릌릍릎릏릐릑릒릓릔릕릖릗릘릙릚릛릜릝릞릟릠릡릢릣릤릥릦릧릨릩릪릫", "리릭릮릯린릱릲릳릴릵릶릷릸릹릺릻림립릾릿맀링맂맃맄맅맆맇"]]


rule "한글2":
    E.append([["마막맊맋만맍많맏말맑맒맓맔맕맖맗맘맙맚맛맜망맞맟맠맡맢맣매맥맦맧맨맩맪맫맬맭맮맯맰맱맲맳맴맵맶맷맸맹맺맻맼맽맾맿먀먁먂먃먄먅먆먇먈먉먊먋먌먍먎먏먐먑먒먓먔먕먖먗먘먙먚먛먜먝먞먟먠먡먢먣먤먥먦먧먨먩먪먫먬먭먮먯먰먱먲먳먴먵먶먷", "머먹먺먻먼먽먾먿멀멁멂멃멄멅멆멇멈멉멊멋멌멍멎멏멐멑멒멓메멕멖멗멘멙멚멛멜멝멞멟멠멡멢멣멤멥멦멧멨멩멪멫멬멭멮멯며멱멲멳면멵멶멷멸멹멺멻멼멽멾멿몀몁몂몃몄명몆몇몈몉몊몋몌몍몎몏몐몑몒몓몔몕몖몗몘몙몚몛몜몝몞몟몠몡몢몣몤몥몦몧", "모목몪몫몬몭몮몯몰몱몲몳몴몵몶몷몸몹몺못몼몽몾몿뫀뫁뫂뫃뫄뫅뫆뫇뫈뫉뫊뫋뫌뫍뫎뫏뫐뫑뫒뫓뫔뫕뫖뫗뫘뫙뫚뫛뫜뫝뫞뫟뫠뫡뫢뫣뫤뫥뫦뫧뫨뫩뫪뫫뫬뫭뫮뫯뫰뫱뫲뫳뫴뫵뫶뫷뫸뫹뫺뫻뫼뫽뫾뫿묀묁묂묃묄묅묆묇묈묉묊묋묌묍묎묏묐묑묒묓묔묕묖묗", "묘묙묚묛묜묝묞묟묠묡묢묣묤묥묦묧묨묩묪묫묬묭묮묯묰묱묲묳무묵묶묷문묹묺묻물묽묾묿뭀뭁뭂뭃뭄뭅뭆뭇뭈뭉뭊뭋뭌뭍뭎뭏뭐뭑뭒뭓뭔뭕뭖뭗뭘뭙뭚뭛뭜뭝뭞뭟뭠뭡뭢뭣뭤뭥뭦뭧뭨뭩뭪뭫뭬뭭뭮뭯뭰뭱뭲뭳뭴뭵뭶뭷뭸뭹뭺뭻뭼뭽뭾뭿뮀뮁뮂뮃뮄뮅뮆뮇", "뮈뮉뮊뮋뮌뮍뮎뮏뮐뮑뮒뮓뮔뮕뮖뮗뮘뮙뮚뮛뮜뮝뮞뮟뮠뮡뮢뮣뮤뮥뮦뮧뮨뮩뮪뮫뮬뮭뮮뮯뮰뮱뮲뮳뮴뮵뮶뮷뮸뮹뮺뮻뮼뮽뮾뮿므믁믂믃믄믅믆믇믈믉믊믋믌믍믎믏믐믑믒믓믔믕믖믗믘믙믚믛믜믝믞믟믠믡믢믣믤믥믦믧믨믩믪믫믬믭믮믯믰믱믲믳믴믵믶믷", "미믹믺믻민믽믾믿밀밁밂밃밄밅밆밇밈밉밊밋밌밍밎및밐밑밒밓"], ["바박밖밗반밙밚받발밝밞밟밠밡밢밣밤밥밦밧밨방밪밫밬밭밮밯배백밲밳밴밵밶밷밸밹밺밻밼밽밾밿뱀뱁뱂뱃뱄뱅뱆뱇뱈뱉뱊뱋뱌뱍뱎뱏뱐뱑뱒뱓뱔뱕뱖뱗뱘뱙뱚뱛뱜뱝뱞뱟뱠뱡뱢뱣뱤뱥뱦뱧뱨뱩뱪뱫뱬뱭뱮뱯뱰뱱뱲뱳뱴뱵뱶뱷뱸뱹뱺뱻뱼뱽뱾뱿벀벁벂벃", "버벅벆벇번벉벊벋벌벍벎벏벐벑벒벓범법벖벗벘벙벚벛벜벝벞벟베벡벢벣벤벥벦벧벨벩벪벫벬벭벮벯벰벱벲벳벴벵벶벷벸벹벺벻벼벽벾벿변볁볂볃별볅볆볇볈볉볊볋볌볍볎볏볐병볒볓볔볕볖볗볘볙볚볛볜볝볞볟볠볡볢볣볤볥볦볧볨볩볪볫볬볭볮볯볰볱볲볳", "보복볶볷본볹볺볻볼볽볾볿봀봁봂봃봄봅봆봇봈봉봊봋봌봍봎봏봐봑봒봓봔봕봖봗봘봙봚봛봜봝봞봟봠봡봢봣봤봥봦봧봨봩봪봫봬봭봮봯봰봱봲봳봴봵봶봷봸봹봺봻봼봽봾봿뵀뵁뵂뵃뵄뵅뵆뵇뵈뵉뵊뵋뵌뵍뵎뵏뵐뵑뵒뵓뵔뵕뵖뵗뵘뵙뵚뵛뵜뵝뵞뵟뵠뵡뵢뵣", "뵤뵥뵦뵧뵨뵩뵪뵫뵬뵭뵮뵯뵰뵱뵲뵳뵴뵵뵶뵷뵸뵹뵺뵻뵼뵽뵾뵿부북붂붃분붅붆붇불붉붊붋붌붍붎붏붐붑붒붓붔붕붖붗붘붙붚붛붜붝붞붟붠붡붢붣붤붥붦붧붨붩붪붫붬붭붮붯붰붱붲붳붴붵붶붷붸붹붺붻붼붽붾붿뷀뷁뷂뷃뷄뷅뷆뷇뷈뷉뷊뷋뷌뷍뷎뷏뷐뷑뷒뷓", "뷔뷕뷖뷗뷘뷙뷚뷛뷜뷝뷞뷟뷠뷡뷢뷣뷤뷥뷦뷧뷨뷩뷪뷫뷬뷭뷮뷯뷰뷱뷲뷳뷴뷵뷶뷷뷸뷹뷺뷻뷼뷽뷾뷿븀븁븂븃븄븅븆븇븈븉븊븋브븍븎븏븐븑븒븓블븕븖븗븘븙븚븛븜븝븞븟븠븡븢븣븤븥븦븧븨븩븪븫븬븭븮븯븰븱븲븳븴븵븶븷븸븹븺븻븼븽븾븿빀빁빂빃", "비빅빆빇빈빉빊빋빌빍빎빏빐빑빒빓빔빕빖빗빘빙빚빛빜빝빞빟"], ["빠빡빢빣빤빥빦빧빨빩빪빫빬빭빮빯빰빱빲빳빴빵빶빷빸빹빺빻빼빽빾빿뺀뺁뺂뺃뺄뺅뺆뺇뺈뺉뺊뺋뺌뺍뺎뺏뺐뺑뺒뺓뺔뺕뺖뺗뺘뺙뺚뺛뺜뺝뺞뺟뺠뺡뺢뺣뺤뺥뺦뺧뺨뺩뺪뺫뺬뺭뺮뺯뺰뺱뺲뺳뺴뺵뺶뺷뺸뺹뺺뺻뺼뺽뺾뺿뻀뻁뻂뻃뻄뻅뻆뻇뻈뻉뻊뻋뻌뻍뻎뻏", "뻐뻑뻒뻓뻔뻕뻖뻗뻘뻙뻚뻛뻜뻝뻞뻟뻠뻡뻢뻣뻤뻥뻦뻧뻨뻩뻪뻫뻬뻭뻮뻯뻰뻱뻲뻳뻴뻵뻶뻷뻸뻹뻺뻻뻼뻽뻾뻿뼀뼁뼂뼃뼄뼅뼆뼇뼈뼉뼊뼋뼌뼍뼎뼏뼐뼑뼒뼓뼔뼕뼖뼗뼘뼙뼚뼛뼜뼝뼞뼟뼠뼡뼢뼣뼤뼥뼦뼧뼨뼩뼪뼫뼬뼭뼮뼯뼰뼱뼲뼳뼴뼵뼶뼷뼸뼹뼺뼻뼼뼽뼾뼿", "뽀뽁뽂뽃뽄뽅뽆뽇뽈뽉뽊뽋뽌뽍뽎뽏뽐뽑뽒뽓뽔뽕뽖뽗뽘뽙뽚뽛뽜뽝뽞뽟뽠뽡뽢뽣뽤뽥뽦뽧뽨뽩뽪뽫뽬뽭뽮뽯뽰뽱뽲뽳뽴뽵뽶뽷뽸뽹뽺뽻뽼뽽뽾뽿뾀뾁뾂뾃뾄뾅뾆뾇뾈뾉뾊뾋뾌뾍뾎뾏뾐뾑뾒뾓뾔뾕뾖뾗뾘뾙뾚뾛뾜뾝뾞뾟뾠뾡뾢뾣뾤뾥뾦뾧뾨뾩뾪뾫뾬뾭뾮뾯", "뾰뾱뾲뾳뾴뾵뾶뾷뾸뾹뾺뾻뾼뾽뾾뾿뿀뿁뿂뿃뿄뿅뿆뿇뿈뿉뿊뿋뿌뿍뿎뿏뿐뿑뿒뿓뿔뿕뿖뿗뿘뿙뿚뿛뿜뿝뿞뿟뿠뿡뿢뿣뿤뿥뿦뿧뿨뿩뿪뿫뿬뿭뿮뿯뿰뿱뿲뿳뿴뿵뿶뿷뿸뿹뿺뿻뿼뿽뿾뿿쀀쀁쀂쀃쀄쀅쀆쀇쀈쀉쀊쀋쀌쀍쀎쀏쀐쀑쀒쀓쀔쀕쀖쀗쀘쀙쀚쀛쀜쀝쀞쀟", "쀠쀡쀢쀣쀤쀥쀦쀧쀨쀩쀪쀫쀬쀭쀮쀯쀰쀱쀲쀳쀴쀵쀶쀷쀸쀹쀺쀻쀼쀽쀾쀿쁀쁁쁂쁃쁄쁅쁆쁇쁈쁉쁊쁋쁌쁍쁎쁏쁐쁑쁒쁓쁔쁕쁖쁗쁘쁙쁚쁛쁜쁝쁞쁟쁠쁡쁢쁣쁤쁥쁦쁧쁨쁩쁪쁫쁬쁭쁮쁯쁰쁱쁲쁳쁴쁵쁶쁷쁸쁹쁺쁻쁼쁽쁾쁿삀삁삂삃삄삅삆삇삈삉삊삋삌삍삎삏", "삐삑삒삓삔삕삖삗삘삙삚삛삜삝삞삟삠삡삢삣삤삥삦삧삨삩삪삫"], ["사삭삮삯산삱삲삳살삵삶삷삸삹삺삻삼삽삾삿샀상샂샃샄샅샆샇새색샊샋샌샍샎샏샐샑샒샓샔샕샖샗샘샙샚샛샜생샞샟샠샡샢샣샤샥샦샧샨샩샪샫샬샭샮샯샰샱샲샳샴샵샶샷샸샹샺샻샼샽샾샿섀섁섂섃섄섅섆섇섈섉섊섋섌섍섎섏섐섑섒섓섔섕섖섗섘섙섚섛", "서석섞섟선섡섢섣설섥섦섧섨섩섪섫섬섭섮섯섰성섲섳섴섵섶섷세섹섺섻센섽섾섿셀셁셂셃셄셅셆셇셈셉셊셋셌셍셎셏셐셑셒셓셔셕셖셗션셙셚셛셜셝셞셟셠셡셢셣셤셥셦셧셨셩셪셫셬셭셮셯셰셱셲셳셴셵셶셷셸셹셺셻셼셽셾셿솀솁솂솃솄솅솆솇솈솉솊솋", "소속솎솏손솑솒솓솔솕솖솗솘솙솚솛솜솝솞솟솠송솢솣솤솥솦솧솨솩솪솫솬솭솮솯솰솱솲솳솴솵솶솷솸솹솺솻솼솽솾솿쇀쇁쇂쇃쇄쇅쇆쇇쇈쇉쇊쇋쇌쇍쇎쇏쇐쇑쇒쇓쇔쇕쇖쇗쇘쇙쇚쇛쇜쇝쇞쇟쇠쇡쇢쇣쇤쇥쇦쇧쇨쇩쇪쇫쇬쇭쇮쇯쇰쇱쇲쇳쇴쇵쇶쇷쇸쇹쇺쇻", "쇼쇽쇾쇿숀숁숂숃숄숅숆숇숈숉숊숋숌숍숎숏숐숑숒숓숔숕숖숗수숙숚숛순숝숞숟술숡숢숣숤숥숦숧숨숩숪숫숬숭숮숯숰숱숲숳숴숵숶숷숸숹숺숻숼숽숾숿쉀쉁쉂쉃쉄쉅쉆쉇쉈쉉쉊쉋쉌쉍쉎쉏쉐쉑쉒쉓쉔쉕쉖쉗쉘쉙쉚쉛쉜쉝쉞쉟쉠쉡쉢쉣쉤쉥쉦쉧쉨쉩쉪쉫", "쉬쉭쉮쉯쉰쉱쉲쉳쉴쉵쉶쉷쉸쉹쉺쉻쉼쉽쉾쉿슀슁슂슃슄슅슆슇슈슉슊슋슌슍슎슏슐슑슒슓슔슕슖슗슘슙슚슛슜슝슞슟슠슡슢슣스슥슦슧슨슩슪슫슬슭슮슯슰슱슲슳슴습슶슷슸승슺슻슼슽슾슿싀싁싂싃싄싅싆싇싈싉싊싋싌싍싎싏싐싑싒싓싔싕싖싗싘싙싚싛", "시식싞싟신싡싢싣실싥싦싧싨싩싪싫심십싮싯싰싱싲싳싴싵싶싷"], ["싸싹싺싻싼싽싾싿쌀쌁쌂쌃쌄쌅쌆쌇쌈쌉쌊쌋쌌쌍쌎쌏쌐쌑쌒쌓쌔쌕쌖쌗쌘쌙쌚쌛쌜쌝쌞쌟쌠쌡쌢쌣쌤쌥쌦쌧쌨쌩쌪쌫쌬쌭쌮쌯쌰쌱쌲쌳쌴쌵쌶쌷쌸쌹쌺쌻쌼쌽쌾쌿썀썁썂썃썄썅썆썇썈썉썊썋썌썍썎썏썐썑썒썓썔썕썖썗썘썙썚썛썜썝썞썟썠썡썢썣썤썥썦썧", "써썩썪썫썬썭썮썯썰썱썲썳썴썵썶썷썸썹썺썻썼썽썾썿쎀쎁쎂쎃쎄쎅쎆쎇쎈쎉쎊쎋쎌쎍쎎쎏쎐쎑쎒쎓쎔쎕쎖쎗쎘쎙쎚쎛쎜쎝쎞쎟쎠쎡쎢쎣쎤쎥쎦쎧쎨쎩쎪쎫쎬쎭쎮쎯쎰쎱쎲쎳쎴쎵쎶쎷쎸쎹쎺쎻쎼쎽쎾쎿쏀쏁쏂쏃쏄쏅쏆쏇쏈쏉쏊쏋쏌쏍쏎쏏쏐쏑쏒쏓쏔쏕쏖쏗", "쏘쏙쏚쏛쏜쏝쏞쏟쏠쏡쏢쏣쏤쏥쏦쏧쏨쏩쏪쏫쏬쏭쏮쏯쏰쏱쏲쏳쏴쏵쏶쏷쏸쏹쏺쏻쏼쏽쏾쏿쐀쐁쐂쐃쐄쐅쐆쐇쐈쐉쐊쐋쐌쐍쐎쐏쐐쐑쐒쐓쐔쐕쐖쐗쐘쐙쐚쐛쐜쐝쐞쐟쐠쐡쐢쐣쐤쐥쐦쐧쐨쐩쐪쐫쐬쐭쐮쐯쐰쐱쐲쐳쐴쐵쐶쐷쐸쐹쐺쐻쐼쐽쐾쐿쑀쑁쑂쑃쑄쑅쑆쑇", "쑈쑉쑊쑋쑌쑍쑎쑏쑐쑑쑒쑓쑔쑕쑖쑗쑘쑙쑚쑛쑜쑝쑞쑟쑠쑡쑢쑣쑤쑥쑦쑧쑨쑩쑪쑫쑬쑭쑮쑯쑰쑱쑲쑳쑴쑵쑶쑷쑸쑹쑺쑻쑼쑽쑾쑿쒀쒁쒂쒃쒄쒅쒆쒇쒈쒉쒊쒋쒌쒍쒎쒏쒐쒑쒒쒓쒔쒕쒖쒗쒘쒙쒚쒛쒜쒝쒞쒟쒠쒡쒢쒣쒤쒥쒦쒧쒨쒩쒪쒫쒬쒭쒮쒯쒰쒱쒲쒳쒴쒵쒶쒷", "쒸쒹쒺쒻쒼쒽쒾쒿쓀쓁쓂쓃쓄쓅쓆쓇쓈쓉쓊쓋쓌쓍쓎쓏쓐쓑쓒쓓쓔쓕쓖쓗쓘쓙쓚쓛쓜쓝쓞쓟쓠쓡쓢쓣쓤쓥쓦쓧쓨쓩쓪쓫쓬쓭쓮쓯쓰쓱쓲쓳쓴쓵쓶쓷쓸쓹쓺쓻쓼쓽쓾쓿씀씁씂씃씄씅씆씇씈씉씊씋씌씍씎씏씐씑씒씓씔씕씖씗씘씙씚씛씜씝씞씟씠씡씢씣씤씥씦씧", "씨씩씪씫씬씭씮씯씰씱씲씳씴씵씶씷씸씹씺씻씼씽씾씿앀앁앂앃"], ["아악앆앇안앉않앋알앍앎앏앐앑앒앓암압앖앗았앙앚앛앜앝앞앟애액앢앣앤앥앦앧앨앩앪앫앬앭앮앯앰앱앲앳앴앵앶앷앸앹앺앻야약앾앿얀얁얂얃얄얅얆얇얈얉얊얋얌얍얎얏얐양얒얓얔얕얖얗얘얙얚얛얜얝얞얟얠얡얢얣얤얥얦얧얨얩얪얫얬얭얮얯얰얱얲얳", "어억얶얷언얹얺얻얼얽얾얿엀엁엂엃엄업없엇었엉엊엋엌엍엎엏에엑엒엓엔엕엖엗엘엙엚엛엜엝엞엟엠엡엢엣엤엥엦엧엨엩엪엫여역엮엯연엱엲엳열엵엶엷엸엹엺엻염엽엾엿였영옂옃옄옅옆옇예옉옊옋옌옍옎옏옐옑옒옓옔옕옖옗옘옙옚옛옜옝옞옟옠옡옢옣", "오옥옦옧온옩옪옫올옭옮옯옰옱옲옳옴옵옶옷옸옹옺옻옼옽옾옿와왁왂왃완왅왆왇왈왉왊왋왌왍왎왏왐왑왒왓왔왕왖왗왘왙왚왛왜왝왞왟왠왡왢왣왤왥왦왧왨왩왪왫왬왭왮왯왰왱왲왳왴왵왶왷외왹왺왻왼왽왾왿욀욁욂욃욄욅욆욇욈욉욊욋욌욍욎욏욐욑욒욓", "요욕욖욗욘욙욚욛욜욝욞욟욠욡욢욣욤욥욦욧욨용욪욫욬욭욮욯우욱욲욳운욵욶욷울욹욺욻욼욽욾욿움웁웂웃웄웅웆웇웈웉웊웋워웍웎웏원웑웒웓월웕웖웗웘웙웚웛웜웝웞웟웠웡웢웣웤웥웦웧웨웩웪웫웬웭웮웯웰웱웲웳웴웵웶웷웸웹웺웻웼웽웾웿윀윁윂윃", "위윅윆윇윈윉윊윋윌윍윎윏윐윑윒윓윔윕윖윗윘윙윚윛윜윝윞윟유육윢윣윤윥윦윧율윩윪윫윬윭윮윯윰윱윲윳윴융윶윷윸윹윺윻으윽윾윿은읁읂읃을읅읆읇읈읉읊읋음읍읎읏읐응읒읓읔읕읖읗의읙읚읛읜읝읞읟읠읡읢읣읤읥읦읧읨읩읪읫읬읭읮읯읰읱읲읳", "이익읶읷인읹읺읻일읽읾읿잀잁잂잃임입잆잇있잉잊잋잌잍잎잏"]])


rule "한글3":
    E.append([["자작잒잓잔잕잖잗잘잙잚잛잜잝잞잟잠잡잢잣잤장잦잧잨잩잪잫재잭잮잯잰잱잲잳잴잵잶잷잸잹잺잻잼잽잾잿쟀쟁쟂쟃쟄쟅쟆쟇쟈쟉쟊쟋쟌쟍쟎쟏쟐쟑쟒쟓쟔쟕쟖쟗쟘쟙쟚쟛쟜쟝쟞쟟쟠쟡쟢쟣쟤쟥쟦쟧쟨쟩쟪쟫쟬쟭쟮쟯쟰쟱쟲쟳쟴쟵쟶쟷쟸쟹쟺쟻쟼쟽쟾쟿", "저적젂젃전젅젆젇절젉젊젋젌젍젎젏점접젒젓젔정젖젗젘젙젚젛제젝젞젟젠젡젢젣젤젥젦젧젨젩젪젫젬젭젮젯젰젱젲젳젴젵젶젷져젹젺젻젼젽젾젿졀졁졂졃졄졅졆졇졈졉졊졋졌졍졎졏졐졑졒졓졔졕졖졗졘졙졚졛졜졝졞졟졠졡졢졣졤졥졦졧졨졩졪졫졬졭졮졯", "조족졲졳존졵졶졷졸졹졺졻졼졽졾졿좀좁좂*좄종*좇좈좉좊좋좌좍좎좏좐좑좒좓좔좕좖좗좘좙좚좛좜좝좞좟좠좡좢좣좤좥좦좧좨좩좪좫좬좭좮좯좰좱좲좳좴좵좶좷좸좹좺좻좼좽좾좿죀죁죂죃죄죅죆죇죈죉죊죋죌죍죎죏죐죑죒죓죔죕죖죗죘죙죚죛죜죝죞죟", "죠죡죢죣죤죥죦죧죨죩죪죫죬죭죮죯죰죱죲죳죴죵죶죷죸죹죺죻주죽죾죿준줁줂줃줄줅줆줇줈줉줊줋줌줍줎줏줐중줒줓줔줕줖줗줘줙줚줛줜줝줞줟줠줡줢줣줤줥줦줧줨줩줪줫줬줭줮줯줰줱줲줳줴줵줶줷줸줹줺줻줼줽줾줿쥀쥁쥂쥃쥄쥅쥆쥇쥈쥉쥊쥋쥌쥍쥎쥏", "쥐쥑쥒쥓쥔쥕쥖쥗쥘쥙쥚쥛쥜쥝쥞쥟쥠쥡쥢쥣쥤쥥쥦쥧쥨쥩쥪쥫쥬쥭쥮쥯쥰쥱쥲쥳쥴쥵쥶쥷쥸쥹쥺쥻쥼쥽쥾쥿즀즁즂즃즄즅즆즇즈즉즊즋즌즍즎즏즐즑즒즓즔즕즖즗즘즙즚즛즜증즞즟즠즡즢즣즤즥즦즧즨즩즪즫즬즭즮즯즰즱즲즳즴즵즶즷즸즹즺즻즼즽즾즿", "지직짂짃진짅짆짇질짉짊짋짌짍짎짏짐집짒짓짔징짖짗짘짙짚짛"], ["짜짝짞짟짠짡짢짣짤짥짦짧짨짩짪짫짬짭짮짯짰짱짲짳짴짵짶짷째짹짺짻짼짽짾짿쨀쨁쨂쨃쨄쨅쨆쨇쨈쨉쨊쨋쨌쨍쨎쨏쨐쨑쨒쨓쨔쨕쨖쨗쨘쨙쨚쨛쨜쨝쨞쨟쨠쨡쨢쨣쨤쨥쨦쨧쨨쨩쨪쨫쨬쨭쨮쨯쨰쨱쨲쨳쨴쨵쨶쨷쨸쨹쨺쨻쨼쨽쨾쨿쩀쩁쩂쩃쩄쩅쩆쩇쩈쩉쩊쩋", "쩌쩍쩎쩏쩐쩑쩒쩓쩔쩕쩖쩗쩘쩙쩚쩛쩜쩝쩞쩟쩠쩡쩢쩣쩤쩥쩦쩧쩨쩩쩪쩫쩬쩭쩮쩯쩰쩱쩲쩳쩴쩵쩶쩷쩸쩹쩺쩻쩼쩽쩾쩿쪀쪁쪂쪃쪄쪅쪆쪇쪈쪉쪊쪋쪌쪍쪎쪏쪐쪑쪒쪓쪔쪕쪖쪗쪘쪙쪚쪛쪜쪝쪞쪟쪠쪡쪢쪣쪤쪥쪦쪧쪨쪩쪪쪫쪬쪭쪮쪯쪰쪱쪲쪳쪴쪵쪶쪷쪸쪹쪺쪻", "쪼쪽쪾쪿쫀쫁쫂쫃쫄쫅쫆쫇쫈쫉쫊쫋쫌쫍쫎쫏쫐쫑쫒쫓쫔쫕쫖쫗쫘쫙쫚쫛쫜쫝쫞쫟쫠쫡쫢쫣쫤쫥쫦쫧쫨쫩쫪쫫쫬쫭쫮쫯쫰쫱쫲쫳쫴쫵쫶쫷쫸쫹쫺쫻쫼쫽쫾쫿쬀쬁쬂쬃쬄쬅쬆쬇쬈쬉쬊쬋쬌쬍쬎쬏쬐쬑쬒쬓쬔쬕쬖쬗쬘쬙쬚쬛쬜쬝쬞쬟쬠쬡쬢쬣쬤쬥쬦쬧쬨쬩쬪쬫", "쬬쬭쬮쬯쬰쬱쬲쬳쬴쬵쬶쬷쬸쬹쬺쬻쬼쬽쬾쬿쭀쭁쭂쭃쭄쭅쭆쭇쭈쭉쭊쭋쭌쭍쭎쭏쭐쭑쭒쭓쭔쭕쭖쭗쭘쭙쭚쭛쭜쭝쭞쭟쭠쭡쭢쭣쭤쭥쭦쭧쭨쭩쭪쭫쭬쭭쭮쭯쭰쭱쭲쭳쭴쭵쭶쭷쭸쭹쭺쭻쭼쭽쭾쭿쮀쮁쮂쮃쮄쮅쮆쮇쮈쮉쮊쮋쮌쮍쮎쮏쮐쮑쮒쮓쮔쮕쮖쮗쮘쮙쮚쮛", "쮜쮝쮞쮟쮠쮡쮢쮣쮤쮥쮦쮧쮨쮩쮪쮫쮬쮭쮮쮯쮰쮱쮲쮳쮴쮵쮶쮷쮸쮹쮺쮻쮼쮽쮾쮿쯀쯁쯂쯃쯄쯅쯆쯇쯈쯉쯊쯋쯌쯍쯎쯏쯐쯑쯒쯓쯔쯕쯖쯗쯘쯙쯚쯛쯜쯝쯞쯟쯠쯡쯢쯣쯤쯥쯦쯧쯨쯩쯪쯫쯬쯭쯮쯯쯰쯱쯲쯳쯴쯵쯶쯷쯸쯹쯺쯻쯼쯽쯾쯿찀찁찂찃찄찅찆찇찈찉찊찋", "찌찍찎찏찐찑찒찓찔찕찖찗찘찙찚찛찜찝찞찟찠찡찢찣찤찥찦찧"], ["차착찪찫찬찭찮찯찰찱찲찳찴찵찶찷참찹찺찻찼창찾찿챀챁챂챃채책챆챇챈챉챊챋챌챍챎챏챐챑챒챓챔챕챖챗챘챙챚챛챜챝챞챟챠챡챢챣챤챥챦챧챨챩챪챫챬챭챮챯챰챱챲챳챴챵챶챷챸챹챺챻챼챽챾챿첀첁첂첃첄첅첆첇첈첉첊첋첌첍첎첏첐첑첒첓첔첕첖첗", "처척첚첛천첝첞첟철첡첢첣첤첥첦첧첨첩첪첫첬청첮첯첰첱첲첳체첵첶첷첸첹첺첻첼첽첾첿쳀쳁쳂쳃쳄쳅쳆쳇쳈쳉쳊쳋쳌쳍쳎쳏쳐쳑쳒쳓쳔쳕쳖쳗쳘쳙쳚쳛쳜쳝쳞쳟쳠쳡쳢쳣쳤쳥쳦쳧쳨쳩쳪쳫쳬쳭쳮쳯쳰쳱쳲쳳쳴쳵쳶쳷쳸쳹쳺쳻쳼쳽쳾쳿촀촁촂촃촄촅촆촇", "초촉촊촋촌촍촎촏촐촑촒촓촔촕촖촗촘촙촚촛촜총촞촟촠촡촢촣촤촥촦촧촨촩촪촫촬촭촮촯촰촱촲촳촴촵촶촷촸촹촺촻촼촽촾촿쵀쵁쵂쵃쵄쵅쵆쵇쵈쵉쵊쵋쵌쵍쵎쵏쵐쵑쵒쵓쵔쵕쵖쵗쵘쵙쵚쵛최쵝쵞쵟쵠쵡쵢쵣쵤쵥쵦쵧쵨쵩쵪쵫쵬쵭쵮쵯쵰쵱쵲쵳쵴쵵쵶쵷", "쵸쵹쵺쵻쵼쵽쵾쵿춀춁춂춃춄춅춆춇춈춉춊춋춌춍춎춏춐춑춒춓추축춖춗춘춙춚춛출춝춞춟춠춡춢춣춤춥춦춧춨충춪춫춬춭춮춯춰춱춲춳춴춵춶춷춸춹춺춻춼춽춾춿췀췁췂췃췄췅췆췇췈췉췊췋췌췍췎췏췐췑췒췓췔췕췖췗췘췙췚췛췜췝췞췟췠췡췢췣췤췥췦췧", "취췩췪췫췬췭췮췯췰췱췲췳췴췵췶췷췸췹췺췻췼췽췾췿츀츁츂츃츄츅츆츇츈츉츊츋츌츍츎츏츐츑츒츓츔츕츖츗츘츙츚츛츜츝츞츟츠측츢츣츤츥츦츧츨츩츪츫츬츭츮츯츰츱츲츳츴층츶츷츸츹츺츻츼츽츾츿칀칁칂칃칄칅칆칇칈칉칊칋칌칍칎칏칐칑칒칓칔칕칖칗", "치칙칚칛친칝칞칟칠칡칢칣칤칥칦칧침칩칪칫칬칭칮칯칰칱칲칳"], ["카칵칶칷칸칹칺칻칼칽칾칿캀캁캂캃캄캅캆캇캈캉캊캋캌캍캎캏캐캑캒캓캔캕캖캗캘캙캚캛캜캝캞캟캠캡캢캣캤캥캦캧캨캩캪캫캬캭캮캯캰캱캲캳캴캵캶캷캸캹캺캻캼캽캾캿컀컁컂컃컄컅컆컇컈컉컊컋컌컍컎컏컐컑컒컓컔컕컖컗컘컙컚컛컜컝컞컟컠컡컢컣", "커컥컦컧컨컩컪컫컬컭컮컯컰컱컲컳컴컵컶컷컸컹컺컻컼컽컾컿케켁켂켃켄켅켆켇켈켉켊켋켌켍켎켏켐켑켒켓켔켕켖켗켘켙켚켛켜켝켞켟켠켡켢켣켤켥켦켧켨켩켪켫켬켭켮켯켰켱켲켳켴켵켶켷켸켹켺켻켼켽켾켿콀콁콂콃콄콅콆콇콈콉콊콋콌콍콎콏콐콑콒콓", "코콕콖콗콘콙콚콛콜콝콞콟콠콡콢콣콤콥콦콧콨콩콪콫콬콭콮콯콰콱콲콳콴콵콶콷콸콹콺콻콼콽콾콿쾀쾁쾂쾃쾄쾅쾆쾇쾈쾉쾊쾋쾌쾍쾎쾏쾐쾑쾒쾓쾔쾕쾖쾗쾘쾙쾚쾛쾜쾝쾞쾟쾠쾡쾢쾣쾤쾥쾦쾧쾨쾩쾪쾫쾬쾭쾮쾯쾰쾱쾲쾳쾴쾵쾶쾷쾸쾹쾺쾻쾼쾽쾾쾿쿀쿁쿂쿃", "쿄쿅쿆쿇쿈쿉쿊쿋쿌쿍쿎쿏쿐쿑쿒쿓쿔쿕쿖쿗쿘쿙쿚쿛쿜쿝쿞쿟쿠쿡쿢쿣쿤쿥쿦쿧쿨쿩쿪쿫쿬쿭쿮쿯쿰쿱쿲쿳쿴쿵쿶쿷쿸쿹쿺쿻쿼쿽쿾쿿퀀퀁퀂퀃퀄퀅퀆퀇퀈퀉퀊퀋퀌퀍퀎퀏퀐퀑퀒퀓퀔퀕퀖퀗퀘퀙퀚퀛퀜퀝퀞퀟퀠퀡퀢퀣퀤퀥퀦퀧퀨퀩퀪퀫퀬퀭퀮퀯퀰퀱퀲퀳", "퀴퀵퀶퀷퀸퀹퀺퀻퀼퀽퀾퀿큀큁큂큃큄큅큆큇큈큉큊큋큌큍큎큏큐큑큒큓큔큕큖큗큘큙큚큛큜큝큞큟큠큡큢큣큤큥큦큧큨큩큪큫크큭큮큯큰큱큲큳클큵큶큷큸큹큺큻큼큽큾큿킀킁킂킃킄킅킆킇킈킉킊킋킌킍킎킏킐킑킒킓킔킕킖킗킘킙킚킛킜킝킞킟킠킡킢킣", "키킥킦킧킨킩킪킫킬킭킮킯킰킱킲킳킴킵킶킷킸킹킺킻킼킽킾킿"], ["타탁탂탃탄탅탆탇탈탉탊탋탌탍탎탏탐탑탒탓탔탕탖탗탘탙탚탛태택탞탟탠탡탢탣탤탥탦탧탨탩탪탫탬탭탮탯탰탱탲탳탴탵탶탷탸탹탺탻탼탽탾탿턀턁턂턃턄턅턆턇턈턉턊턋턌턍턎턏턐턑턒턓턔턕턖턗턘턙턚턛턜턝턞턟턠턡턢턣턤턥턦턧턨턩턪턫턬턭턮턯", "터턱턲턳턴턵턶턷털턹턺턻턼턽턾턿텀텁텂텃텄텅텆텇텈텉텊텋테텍텎텏텐텑텒텓텔텕텖텗텘텙텚텛템텝텞텟텠텡텢텣텤텥텦텧텨텩텪텫텬텭텮텯텰텱텲텳텴텵텶텷텸텹텺텻텼텽텾텿톀톁톂톃톄톅톆톇톈톉톊톋톌톍톎톏톐톑톒톓톔톕톖톗톘톙톚톛톜톝톞톟", "토톡톢톣톤톥톦톧톨톩톪톫톬톭톮톯톰톱톲톳톴통톶톷톸톹톺톻톼톽톾톿퇀퇁퇂퇃퇄퇅퇆퇇퇈퇉퇊퇋퇌퇍퇎퇏퇐퇑퇒퇓퇔퇕퇖퇗퇘퇙퇚퇛퇜퇝퇞퇟퇠퇡퇢퇣퇤퇥퇦퇧퇨퇩퇪퇫퇬퇭퇮퇯퇰퇱퇲퇳퇴퇵퇶퇷퇸퇹퇺퇻퇼퇽퇾퇿툀툁툂툃툄툅툆툇툈툉툊툋툌툍툎툏", "툐툑툒툓툔툕툖툗툘툙툚툛툜툝툞툟툠툡툢툣툤툥툦툧툨툩툪툫투툭툮툯툰툱툲툳툴툵툶툷툸툹툺툻툼툽툾툿퉀퉁퉂퉃퉄퉅퉆퉇퉈퉉퉊퉋퉌퉍퉎퉏퉐퉑퉒퉓퉔퉕퉖퉗퉘퉙퉚퉛퉜퉝퉞퉟퉠퉡퉢퉣퉤퉥퉦퉧퉨퉩퉪퉫퉬퉭퉮퉯퉰퉱퉲퉳퉴퉵퉶퉷퉸퉹퉺퉻퉼퉽퉾퉿", "튀튁튂튃튄튅튆튇튈튉튊튋튌튍튎튏튐튑튒튓튔튕튖튗튘튙튚튛튜튝튞튟튠튡튢튣튤튥튦튧튨튩튪튫튬튭튮튯튰튱튲튳튴튵튶튷트특튺튻튼튽튾튿틀틁틂틃틄틅틆틇틈틉틊틋틌틍틎틏틐틑틒틓틔틕틖틗틘틙틚틛틜틝틞틟틠틡틢틣틤틥틦틧틨틩틪틫틬틭틮틯", "티틱틲틳틴틵틶틷틸틹틺틻틼틽틾틿팀팁팂팃팄팅팆팇팈팉팊팋"], ["파팍팎팏판팑팒팓팔팕팖팗팘팙팚팛팜팝팞팟팠팡팢팣팤팥팦팧패팩팪팫팬팭팮팯팰팱팲팳팴팵팶팷팸팹팺팻팼팽팾팿퍀퍁퍂퍃퍄퍅퍆퍇퍈퍉퍊퍋퍌퍍퍎퍏퍐퍑퍒퍓퍔퍕퍖퍗퍘퍙퍚퍛퍜퍝퍞퍟퍠퍡퍢퍣퍤퍥퍦퍧퍨퍩퍪퍫퍬퍭퍮퍯퍰퍱퍲퍳퍴퍵퍶퍷퍸퍹퍺퍻", "퍼퍽퍾퍿펀펁펂펃펄펅펆펇펈펉펊펋펌펍펎펏펐펑펒펓펔펕펖펗페펙펚펛펜펝펞펟펠펡펢펣펤펥펦펧펨펩펪펫펬펭펮펯펰펱펲펳펴펵펶펷편펹펺펻펼펽펾펿폀폁폂폃폄폅폆폇폈평폊폋폌폍폎폏폐폑폒폓폔폕폖폗폘폙폚폛폜폝폞폟폠폡폢폣폤폥폦폧폨폩폪폫", "포폭폮폯폰폱폲폳폴폵폶폷폸폹폺폻폼폽폾폿퐀퐁퐂퐃퐄퐅퐆퐇퐈퐉퐊퐋퐌퐍퐎퐏퐐퐑퐒퐓퐔퐕퐖퐗퐘퐙퐚퐛퐜퐝퐞퐟퐠퐡퐢퐣퐤퐥퐦퐧퐨퐩퐪퐫퐬퐭퐮퐯퐰퐱퐲퐳퐴퐵퐶퐷퐸퐹퐺퐻퐼퐽퐾퐿푀푁푂푃푄푅푆푇푈푉푊푋푌푍푎푏푐푑푒푓푔푕푖푗푘푙푚푛", "표푝푞푟푠푡푢푣푤푥푦푧푨푩푪푫푬푭푮푯푰푱푲푳푴푵푶푷푸푹푺푻푼푽푾푿풀풁풂풃풄풅풆풇품풉풊풋풌풍풎풏풐풑풒풓풔풕풖풗풘풙풚풛풜풝풞풟풠풡풢풣풤풥풦풧풨풩풪풫풬풭풮풯풰풱풲풳풴풵풶풷풸풹풺풻풼풽풾풿퓀퓁퓂퓃퓄퓅퓆퓇퓈퓉퓊퓋", "퓌퓍퓎퓏퓐퓑퓒퓓퓔퓕퓖퓗퓘퓙퓚퓛퓜퓝퓞퓟퓠퓡퓢퓣퓤퓥퓦퓧퓨퓩퓪퓫퓬퓭퓮퓯퓰퓱퓲퓳퓴퓵퓶퓷퓸퓹퓺퓻퓼퓽퓾퓿픀픁픂픃프픅픆픇픈픉픊픋플픍픎픏픐픑픒픓픔픕픖픗픘픙픚픛픜픝픞픟픠픡픢픣픤픥픦픧픨픩픪픫픬픭픮픯픰픱픲픳픴픵픶픷픸픹픺픻", "피픽픾픿핀핁핂핃필핅핆핇핈핉핊핋핌핍핎핏핐핑핒핓핔핕핖핗"], ["하학핚핛한핝핞핟할핡핢핣핤핥핦핧함합핪핫핬항핮핯핰핱핲핳해핵핶핷핸핹핺핻핼핽핾핿햀햁햂햃햄햅햆햇했행햊햋햌햍햎햏햐햑햒햓햔햕햖햗햘햙햚햛햜햝햞햟햠햡햢햣햤향햦햧햨햩햪햫햬햭햮햯햰햱햲햳햴햵햶햷햸햹햺햻햼햽햾햿헀헁헂헃헄헅헆헇", "허헉헊헋헌헍헎헏헐헑헒헓헔헕헖헗험헙헚헛헜헝헞헟헠헡헢헣헤헥헦헧헨헩헪헫헬헭헮헯헰헱헲헳헴헵헶헷헸헹헺헻헼헽헾헿혀혁혂혃현혅혆혇혈혉혊혋혌혍혎혏혐협혒혓혔형혖혗혘혙혚혛혜혝혞혟혠혡혢혣혤혥혦혧혨혩혪혫혬혭혮혯혰혱혲혳혴혵혶혷", "호혹혺혻혼혽혾혿홀홁홂홃홄홅홆홇홈홉홊홋홌홍홎홏홐홑홒홓화확홖홗환홙홚홛활홝홞홟홠홡홢홣홤홥홦홧홨황홪홫홬홭홮홯홰홱홲홳홴홵홶홷홸홹홺홻홼홽홾홿횀횁횂횃횄횅횆횇횈횉횊횋회획횎횏횐횑횒횓횔횕횖횗횘횙횚횛횜횝횞횟횠횡횢횣횤횥횦횧", "효횩횪횫횬횭횮횯횰횱횲횳횴횵횶횷횸횹횺횻횼횽횾횿훀훁훂훃후훅훆훇훈훉훊훋훌훍훎훏훐훑훒훓훔훕훖훗훘훙훚훛훜훝훞훟훠훡훢훣훤훥훦훧훨훩훪훫훬훭훮훯훰훱훲훳훴훵훶훷훸훹훺훻훼훽훾훿휀휁휂휃휄휅휆휇휈휉휊휋휌휍휎휏휐휑휒휓휔휕휖휗", "휘휙휚휛휜휝휞휟휠휡휢휣휤휥휦휧휨휩휪휫휬휭휮휯휰휱휲휳휴휵휶휷휸휹휺휻휼휽휾휿흀흁흂흃흄흅흆흇흈흉흊흋흌흍흎흏흐흑흒흓흔흕흖흗흘흙흚흛흜흝흞흟흠흡흢흣흤흥흦흧흨흩흪흫희흭흮흯흰흱흲흳흴흵흶흷흸흹흺흻흼흽흾흿힀힁힂힃힄힅힆힇", "히힉힊힋힌힍힎힏힐힑힒힓힔힕힖힗힘힙힚힛힜힝힞힟힠힡힢힣"]])


rule "플레이어설정":
    @Event playerJoined
    
    eventPlayer.disableGamemodeHud()
    if any([strContains("{0}".format(eventPlayer), player) for player in AE]) or "{0}".format(eventPlayer) in AB:
        if eventPlayer == hostPlayer:
            removeFromGame(eventPlayer)
        else:
            eventPlayer.disableTextChat()
            eventPlayer.disableVoiceChat(true, true, true)
            eventPlayer.disableScoreboard()
            eventPlayer.setAllowedHeroes(Hero.REAPER)
            eventPlayer.AP = true
            waitUntil(eventPlayer.hasSpawned(), 99999)
            hudText(eventPlayer, " 당신은 블랙리스트에 등록되어있어 게임에 참여할 수 없습니다. ", "\r\n\r\n", null, HudPosition.TOP, 0, Color.RED, Color.WHITE, Color.WHITE, HudReeval.NONE, SpecVisibility.DEFAULT)
            eventPlayer.M = getLastCreatedText()
            eventPlayer.setGravity(0)
            eventPlayer.teleport(vect(0, 200, 0))
            smallMessage(getAllPlayers(), "{0} 님은 블랙리스트에 등록되어있어 게임에 참여할 수 없습니다.".format(eventPlayer))
            eventPlayer.startFacing(Vector.UP, 10000, Relativity.TO_WORLD, FacingReeval.NONE)
            while eventPlayer.AP:
                eventPlayer.forceButtonPress(Button.ABILITY_2)
                wait()
            eventPlayer.forceButtonPress(Button.SECONDARY_FIRE)
            destroyHudText(eventPlayer.M)
            eventPlayer.setGravity(100)
            eventPlayer.enableTextChat()
            eventPlayer.enableVoiceChat()
            eventPlayer.stopFacing()
            eventPlayer.enableScoreboard()
            goto RULE_START
    else:
        waitUntil(eventPlayer.hasSpawned(), 99999)
        AC.append(eventPlayer)
        eventPlayer.startCamera(vect(0, 10, 5), vect(0, 10, 20), 0)
        eventPlayer.disallowButton(Button.ABILITY_2)
        eventPlayer.disallowButton(Button.PRIMARY_FIRE)
        eventPlayer.disallowButton(Button.SECONDARY_FIRE)
        eventPlayer.disallowButton(Button.ABILITY_1)
        eventPlayer.disallowButton(Button.ULTIMATE)
        eventPlayer.disableHeroHUD()
        eventPlayer.setDamageReceived(0)
        eventPlayer.J = vect(0, 0, 0)
        eventPlayer.M = 0.8
        eventPlayer.Z = M
        eventPlayer.O = M
        eventPlayer.teleport(vect((1 + floor(eventPlayer.getSlot() / 2)) * (2 if eventPlayer.getSlot() % 2 else -2), 0, 19))
        eventPlayer.D = Color.WHITE
        createInWorldText(AC, "{0}{1} {2}".format(M if AA else "{0}. ".format(1 + AC.index(eventPlayer)), eventPlayer, "{0} {1}".format(eventPlayer.getScore() if AH else M, "그리는 중" if eventPlayer == A else "출제자" if eventPlayer == P else "정답" if eventPlayer.AM else M)), vect(15.8, 16 - 0.5 * eventPlayer.getSlot(), 20), 1.5, Clip.NONE, WorldTextReeval.VISIBILITY_STRING_AND_COLOR, Color.BLUE if eventPlayer == A else Color.GREEN if eventPlayer == P else Color.WHITE, SpecVisibility.DEFAULT)
        createInWorldText(AC, "{0}: {1}?".format(eventPlayer, eventPlayer.AE) if eventPlayer.R > getTotalTimeElapsed() else M, eventPlayer.getEyePosition() + (vect(0, 0.5 + 0.1 * (sin(getTotalTimeElapsed() * 10)), 0)), 2, Clip.NONE, WorldTextReeval.VISIBILITY_POSITION_AND_STRING, Color.GREEN, SpecVisibility.DEFAULT)
        if eventPlayer == hostPlayer or AL < 2 and N:
            if AL == 2:
                goto lbl_0
            eventPlayer.T = true
            wait()
            lbl_0:
            eventPlayer.AI = true
        AC.startForcingOutlineFor(AC, false, Color.WHITE, OutlineVisibility.DEFAULT)
        eventPlayer.startScalingSize(1.5, true)
        eventPlayer.startTransformingThrottle(1, 0.01, Vector.FORWARD)
        eventPlayer.AF = 100
        eventPlayer.setJumpVerticalSpeed(150)
        eventPlayer.setHealth(eventPlayer.getMaxHealth())
        eventPlayer.AJ = 0.6
        eventPlayer.setAimSpeed(150)


rule "화가설정":
    @Event eachPlayer
    @Condition eventPlayer.S != eventPlayer.X
    
    eventPlayer.X = not eventPlayer.X
    if eventPlayer.X:
        eventPlayer.A = vect(0, 0, 0)
        chase(eventPlayer.A, vect(0, 10, 19.9) + 0.1 * (vect(eventPlayer.getHorizontalFacingAngle(), -1 * eventPlayer.getVerticalFacingAngle(), 0)), rate=10000, ChaseReeval.DESTINATION_AND_RATE)
        eventPlayer.B = []
        eventPlayer.C = 0.2
        eventPlayer.D = Color.BLACK
        eventPlayer.AN = -1
        Sub0()
    else:
        destroyEffect(eventPlayer.K)
        for eventPlayer.F in range(len(eventPlayer.B)):
            destroyEffect(eventPlayer.B[eventPlayer.F][2])
        eventPlayer.B = []
        eventPlayer.G = false
        eventPlayer.I = false
        eventPlayer.AL = false
        destroyEffect(eventPlayer.AK)
        stopChasingVariable(eventPlayer.A)
    eventPlayer.setMeleeEnabled(not eventPlayer.X)


rule "점":
    @Event eachPlayer
    @Condition eventPlayer.S == true
    @Condition eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) == true
    @Condition abs(eventPlayer.A.x) < 13
    @Condition abs(12.95 - eventPlayer.A.y) < 5.95
    @Condition getNumberOfEntityIds() < 256
    @Condition eventPlayer.H == true
    @Condition eventPlayer.G == false
    @Condition getMatchTime() == true
    
    eventPlayer.AD = true
    if eventPlayer.H == 4 or (not (eventPlayer.AL or eventPlayer.isHoldingButton(Button.ABILITY_1))):
        if distance(eventPlayer.A, eventPlayer.J) > eventPlayer.C:
            if eventPlayer.H == 1:
                createEffect(AC, Effect.SPHERE, eventPlayer.D, eventPlayer.A, eventPlayer.C, EffectReeval.VISIBILITY)
            elif eventPlayer.H == 2:
                createEffect(AC, Effect.CLOUD, eventPlayer.D, eventPlayer.A, eventPlayer.C, EffectReeval.VISIBILITY)
            elif eventPlayer.H == 3:
                createEffect(AC, Effect.GOOD_AURA, eventPlayer.D, eventPlayer.A, eventPlayer.C, EffectReeval.VISIBILITY)
            elif eventPlayer.H == 4:
                createEffect(AC, Effect.ORB, eventPlayer.D, eventPlayer.A, 1, EffectReeval.VISIBILITY)
            eventPlayer.B.append([[eventPlayer.A, eventPlayer.C, getLastCreatedEntity()]])
            eventPlayer.J = eventPlayer.A
    wait()
    if RULE_CONDITION:
        goto RULE_START
    eventPlayer.AD = false
    if not eventPlayer.isHoldingButton(Button.ABILITY_1):
        eventPlayer.J = vect(0, 0, 0)


rule "선":
    @Event eachPlayer
    @Condition (eventPlayer.S and getNumberOfEntityIds() <= 256 and getMatchTime() and eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) and not eventPlayer.H and abs(eventPlayer.A.x) < 13 and abs(12.95 - eventPlayer.A.y) < 5.95) != (eventPlayer.I == true)
    @Condition eventPlayer.G == false
    
    eventPlayer.I = not eventPlayer.I
    playEffect(eventPlayer, DynamicEffect.BUFF_EXPLOSION_SOUND, Color.WHITE, vect(0, 10, 0), 10)
    if not eventPlayer.I and distance(eventPlayer.A, eventPlayer.J) > 0.1:
        Sub4()
    eventPlayer.J = eventPlayer.A if eventPlayer.I else vect(0, 0, 0)


rule "곡선":
    @Event eachPlayer
    @Condition getNumberOfEntityIds() < 256
    @Condition eventPlayer.I == true
    @Condition distance(eventPlayer.A, eventPlayer.J) > eventPlayer.AJ
    @Condition eventPlayer.isHoldingButton(Button.ABILITY_1) == false
    
    Sub4()
    eventPlayer.J = eventPlayer.A
    wait()
    if RULE_CONDITION:
        goto RULE_START


rule "시프트로 그리기":
    @Event eachPlayer
    @Condition eventPlayer.X == true
    @Condition eventPlayer.H != 4
    @Condition (((not (eventPlayer.H and eventPlayer.H != 2 and eventPlayer.J and (abs(((eventPlayer.A + eventPlayer.J).x) / 2) > 13 - distance(eventPlayer.A, eventPlayer.J) / 2 or abs(12.95 - (((eventPlayer.A + eventPlayer.J).y) / 2)) > 5.95 - distance(eventPlayer.A, eventPlayer.J) / 2))) and eventPlayer.isHoldingButton(Button.ABILITY_1)) and (eventPlayer.I or eventPlayer.AD)) != eventPlayer.AL
    
    eventPlayer.AL = not eventPlayer.AL
    if eventPlayer.AL:
        eventPlayer.J = eventPlayer.A
        if eventPlayer.H == 1:
            createEffect(AC, Effect.SPHERE, eventPlayer.D, (eventPlayer.A + evalOnce(eventPlayer.J)) / 2, distance(eventPlayer.A, evalOnce(eventPlayer.J)) / 2, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
        elif eventPlayer.H == 2:
            createEffect(AC, Effect.CLOUD, eventPlayer.D, (eventPlayer.A + evalOnce(eventPlayer.J)) / 2, distance(eventPlayer.A, evalOnce(eventPlayer.J)) / 2, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
        elif eventPlayer.H == 3:
            createEffect(AC, Effect.GOOD_AURA, eventPlayer.D, (eventPlayer.A + evalOnce(eventPlayer.J)) / 2, distance(eventPlayer.A, evalOnce(eventPlayer.J)) / 2, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
        elif eventPlayer.D == Color.BLACK:
            createBeam(AC, Beam.GRAPPLE, evalOnce(eventPlayer.J), eventPlayer.A, Color.WHITE, EffectReeval.POSITION_AND_RADIUS)
        else:
            createBeam(AC, Beam.GOOD, evalOnce(eventPlayer.J), eventPlayer.A, eventPlayer.D, EffectReeval.POSITION_AND_RADIUS)
        eventPlayer.AK = getLastCreatedEntity()
    else:
        destroyEffect(eventPlayer.AK)
        if eventPlayer.J:
            if eventPlayer.H:
                if eventPlayer.H == 1:
                    createEffect(AC, Effect.SPHERE, eventPlayer.D, (eventPlayer.A + eventPlayer.J) / 2, distance(eventPlayer.A, eventPlayer.J) / 2, EffectReeval.VISIBILITY)
                elif eventPlayer.H == 2:
                    createEffect(AC, Effect.CLOUD, eventPlayer.D, (eventPlayer.A + eventPlayer.J) / 2, distance(eventPlayer.A, eventPlayer.J) / 2, EffectReeval.VISIBILITY)
                elif eventPlayer.H == 3:
                    createEffect(AC, Effect.GOOD_AURA, eventPlayer.D, (eventPlayer.A + eventPlayer.J) / 2, distance(eventPlayer.A, eventPlayer.J) / 2, EffectReeval.VISIBILITY)
                elif eventPlayer.H == 4:
                    createEffect(AC, Effect.ORB, eventPlayer.D, (eventPlayer.A + eventPlayer.J) / 2, distance(eventPlayer.A, eventPlayer.J) / 2, EffectReeval.VISIBILITY)
                eventPlayer.B.append([[(eventPlayer.A + eventPlayer.J) / 2, distance(eventPlayer.A, eventPlayer.J) / 2, getLastCreatedEntity()]])
                playEffect(eventPlayer, DynamicEffect.BUFF_EXPLOSION_SOUND, Color.WHITE, vect(0, 10, 0), 10)
            elif eventPlayer.isHoldingButton(Button.PRIMARY_FIRE):
                Sub4()
        eventPlayer.J = vect(0, 0, 0)
    wait(0)
    if RULE_CONDITION:
        goto RULE_START


def Sub4():
    @Name "선 서브"
    
    if not eventPlayer.J:
        return
    if eventPlayer.D == Color.BLACK:
        createBeam(AC, Beam.GRAPPLE, eventPlayer.J, eventPlayer.A, Color.WHITE, EffectReeval.VISIBILITY)
    else:
        createBeam(AC, Beam.GOOD, eventPlayer.J, eventPlayer.A, eventPlayer.D, EffectReeval.VISIBILITY)
    eventPlayer.B.append([[eventPlayer.J, eventPlayer.A, getLastCreatedEntity(), directionTowards(eventPlayer.J, eventPlayer.A)]])


rule "이펙트바꾸기":
    @Event eachPlayer
    @Condition eventPlayer.S == true
    @Condition any([eventPlayer.isHoldingButton(i) for i in [Button.PRIMARY_FIRE, Button.ABILITY_2, Button.ULTIMATE, Button.RELOAD, Button.MELEE]]) == true
    @Condition getMatchTime() == true
    
    eventPlayer.E = B.index([player for player in B if distance(player, eventPlayer.A) < 0.5])
    if eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) and eventPlayer.E < 0:
        return
    if eventPlayer.isHoldingButton(Button.ULTIMATE) or eventPlayer.isHoldingButton(Button.ABILITY_2) or abs(eventPlayer.E - 0.5) == 0.5:
        if eventPlayer.G:
            eventPlayer.D = eventPlayer.L
            eventPlayer.G = false
        eventPlayer.H = (eventPlayer.H + (1 if eventPlayer.E > 0 or eventPlayer.isHoldingButton(Button.ABILITY_2) else 4)) % 5
        Sub0()
    elif eventPlayer.isHoldingButton(Button.RELOAD) or eventPlayer.isHoldingButton(Button.MELEE) or abs(eventPlayer.E - 2.5) == 0.5:
        if eventPlayer.isHoldingButton(Button.SECONDARY_FIRE) or eventPlayer.G:
            eventPlayer.M = max(min(eventPlayer.M + (0.1 if eventPlayer.isHoldingButton(Button.RELOAD) or eventPlayer.E == 2 else -0.1), 1.3), 0.2)
        elif eventPlayer.H:
            eventPlayer.C = max(min(eventPlayer.C + (0.1 if eventPlayer.isHoldingButton(Button.RELOAD) or eventPlayer.E == 2 else -0.1), 1), 0.1)
        else:
            eventPlayer.AJ = max(min(eventPlayer.AJ + (0.2 if eventPlayer.isHoldingButton(Button.RELOAD) or eventPlayer.E == 2 else -0.2), 2), 0.2)
    elif eventPlayer.E == 4:
        setMatchTime(0)
        smallMessage(getAllPlayers(), "그리기 포기")
    else:
        if eventPlayer.G:
            goto lbl_0
        eventPlayer.L = eventPlayer.D
        lbl_0:
        eventPlayer.D = D[eventPlayer.E - 5]
        if eventPlayer.E == 5:
            if eventPlayer.G:
                for eventPlayer.F in range(len(eventPlayer.B)):
                    destroyEffect(eventPlayer.B[eventPlayer.F][2])
                eventPlayer.D = eventPlayer.L
                eventPlayer.G = false
                eventPlayer.B = []
                Sub0()
            else:
                destroyEffect(eventPlayer.K)
                eventPlayer.G = true
                createEffect(eventPlayer, Effect.GOOD_AURA, Color.WHITE, C - vect(0, 0, 0.1), eventPlayer.M, EffectReeval.VISIBILITY_POSITION_RADIUS_AND_COLOR)
                eventPlayer.K = getLastCreatedEntity()
        else:
            if eventPlayer.G:
                eventPlayer.G = false
            Sub0()
    playEffect(eventPlayer, DynamicEffect.BUFF_EXPLOSION_SOUND, Color.WHITE, vect(0, 10, 0), 10)
    if eventPlayer.W:
        goto lbl_1
    wait(0.4, Wait.ABORT_WHEN_FALSE)
    eventPlayer.W = true
    lbl_1:
    wait(0.05)
    if RULE_CONDITION:
        goto RULE_START
    eventPlayer.W = false


def Sub0():
    @Name "이펙트서브"
    
    destroyEffect(eventPlayer.K)
    if eventPlayer.H == 1:
        createEffect(eventPlayer, Effect.SPHERE, eventPlayer.D, C, eventPlayer.C, EffectReeval.VISIBILITY_POSITION_RADIUS_AND_COLOR)
    elif eventPlayer.H == 2:
        createEffect(eventPlayer, Effect.CLOUD, eventPlayer.D, C, eventPlayer.C, EffectReeval.VISIBILITY_POSITION_RADIUS_AND_COLOR)
    elif eventPlayer.H == 3:
        createEffect(eventPlayer, Effect.GOOD_AURA, eventPlayer.D, C, eventPlayer.C, EffectReeval.VISIBILITY_POSITION_RADIUS_AND_COLOR)
    elif eventPlayer.H == 4:
        createEffect(eventPlayer, Effect.ORB, eventPlayer.D, C, 1, EffectReeval.VISIBILITY_POSITION_RADIUS_AND_COLOR)
    elif eventPlayer.D == Color.BLACK:
        createBeam(eventPlayer, Beam.GRAPPLE, C - Vector.LEFT * eventPlayer.AJ / 2, C + Vector.LEFT * eventPlayer.AJ / 2, Color.WHITE, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
    else:
        createBeam(eventPlayer, Beam.GOOD, C - Vector.LEFT * eventPlayer.AJ / 2, C + Vector.LEFT * eventPlayer.AJ / 2, eventPlayer.D, EffectReeval.VISIBILITY_POSITION_RADIUS_AND_COLOR)
    eventPlayer.K = getLastCreatedEntity()


rule "이펙트최대":
    @Condition getNumberOfEntityIds() == 256
    
    smallMessage(A, "더 이상 그릴수 없습니다. 지워야 그릴 수 있습니다.")
    playEffect(A, DynamicEffect.BUFF_IMPACT_SOUND, Color.WHITE, vect(0, 10, 0), 50)


rule "지우개":
    @Event eachPlayer
    @Condition eventPlayer.S == true
    @Condition (eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) and eventPlayer.G or eventPlayer.isHoldingButton(Button.SECONDARY_FIRE)) == true
    @Condition abs(eventPlayer.A.x) < 13
    @Condition abs(12.95 - eventPlayer.A.y) < 5.95
    @Condition eventPlayer.isHoldingButton(Button.ABILITY_1) == false
    @Condition getMatchTime() == true
    
    eventPlayer.E = [player for player in eventPlayer.B if ((distance(eventPlayer.A, (player if angleBetweenVectors(player[3], directionTowards(player, eventPlayer.A)) > 90 else player[1] if angleBetweenVectors(-1 * player[3], directionTowards(player[1], eventPlayer.A)) > 90 else player + player[3] * dotProduct(player[3], vectorTowards(player, eventPlayer.A))) if player[3] else player)) < (eventPlayer.M + (0 if player[3] else player[1])))]
    for eventPlayer.F in range(len(eventPlayer.E)):
        destroyEffect(eventPlayer.E[eventPlayer.F][2])
    eventPlayer.B.remove(eventPlayer.E)
    wait()
    if RULE_CONDITION:
        goto RULE_START
    if not eventPlayer.B:
        playEffect(eventPlayer, DynamicEffect.DEBUFF_IMPACT_SOUND, Color.WHITE, vect(0, 10, 0), 10)
        if eventPlayer.G:
            eventPlayer.D = eventPlayer.L
        eventPlayer.G = false
        Sub0()


rule "마지막이펙트지우개":
    @Event eachPlayer
    @Condition eventPlayer.S == true
    @Condition (eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) and eventPlayer.G or eventPlayer.isHoldingButton(Button.SECONDARY_FIRE)) == true
    @Condition eventPlayer.isHoldingButton(Button.ABILITY_1) == true
    @Condition getMatchTime() == true
    
    destroyEffect(eventPlayer.B.last()[2])
    del eventPlayer.B[len(eventPlayer.B) - 1]
    if eventPlayer.W:
        goto lbl_0
    playEffect(eventPlayer, DynamicEffect.DEBUFF_IMPACT_SOUND, Color.WHITE, vect(0, 10, 0), 10)
    wait(0.4, Wait.ABORT_WHEN_FALSE)
    eventPlayer.W = true
    lbl_0:
    if eventPlayer.B:
        wait(0.05)
        if RULE_CONDITION:
            goto RULE_START
    else:
        playEffect(eventPlayer, DynamicEffect.DEBUFF_IMPACT_SOUND, Color.WHITE, vect(0, 10, 0), 10)
        if eventPlayer.G:
            eventPlayer.D = eventPlayer.L
        eventPlayer.G = false
        Sub0()
    eventPlayer.W = false


rule "클릭":
    @Event eachPlayer
    @Condition eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) == true
    @Condition eventPlayer.T == true
    @Condition any([distance(vect(eventPlayer.getHorizontalFacingAngle(), eventPlayer.getVerticalFacingAngle(), 0), player) < 10 for player in H]) == true
    
    eventPlayer.N = I[H.index(sorted(H, lambda player: distance(player, vect(eventPlayer.getHorizontalFacingAngle(), eventPlayer.getVerticalFacingAngle(), 0)))[0])]
    if eventPlayer.N == 100:
        if eventPlayer.isHoldingButton(Button.ABILITY_1):
            goto lbl_0
        eventPlayer.V = not eventPlayer.V
        lbl_0:
    elif eventPlayer.N == 101:
        async(Sub2, AsyncBehavior.RESTART)
    elif eventPlayer.N == 102:
        Sub3()
    elif strLen(eventPlayer.Z) < X:
        eventPlayer.N = eventPlayer.N.last() if eventPlayer.V else eventPlayer.N[0]
        Sub1()
        eventPlayer.N = 0
        if eventPlayer.isHoldingButton(Button.ABILITY_1):
            goto lbl_1
        eventPlayer.V = false
        lbl_1:
    playEffect(eventPlayer, DynamicEffect.BUFF_EXPLOSION_SOUND, Color.WHITE, vect(0, 10, 0), 10)


def Sub1():
    @Name "모아쓰기"
    
    eventPlayer.U[eventPlayer.Y] = eventPlayer.N
    if not eventPlayer.Y:
        eventPlayer.O = [G.charAt(eventPlayer.N)]
        if eventPlayer.N < 19:
            eventPlayer.Y = 1
        else:
            eventPlayer.Z = "{0}{1}".format(eventPlayer.Z, eventPlayer.O.last())
            eventPlayer.Y = 0
            eventPlayer.O = [M]
            eventPlayer.U = false
    elif eventPlayer.Y == 1:
        if eventPlayer.N < 19:
            eventPlayer.Z = "{0}{1}".format(eventPlayer.Z, eventPlayer.O.last())
            eventPlayer.U = eventPlayer.N
            eventPlayer.O = [G.charAt(eventPlayer.N)]
        else:
            eventPlayer.AC = floor(((eventPlayer.N - 19) * 28) / 112)
            eventPlayer.Q = ((eventPlayer.N - 19) * 28) % 112
            eventPlayer.O.append(E[eventPlayer.U][eventPlayer.AC].charAt(eventPlayer.Q))
            eventPlayer.Y = 2
        if eventPlayer.isHoldingButton(Button.ULTIMATE) and eventPlayer.isHoldingButton(Button.ABILITY_2):
            eventPlayer.Z = R
            eventPlayer.O = M
    elif eventPlayer.Y == 2:
        if eventPlayer.N < 19:
            if any([i == eventPlayer.N for i in [4, 8, 13]]):
                eventPlayer.Z = "{0}{1}".format(eventPlayer.Z, eventPlayer.O.last())
                eventPlayer.O = [G.charAt(eventPlayer.N)]
                eventPlayer.U = eventPlayer.N
                eventPlayer.Y = 1
            else:
                eventPlayer.U[4] = eventPlayer.N
                eventPlayer.Q += J[eventPlayer.N]
                eventPlayer.O.append(E[eventPlayer.U][eventPlayer.AC].charAt(eventPlayer.Q))
                eventPlayer.Y = 3
        else:
            eventPlayer.AB = ([player for player in K if player[0] == eventPlayer.U[1] and player[1] == eventPlayer.N]).last()
            eventPlayer.AB = eventPlayer.AB.last()
            if eventPlayer.AB:
                eventPlayer.AC = floor(((eventPlayer.AB - 19) * 28) / 112)
                eventPlayer.Q = ((eventPlayer.AB - 19) * 28) % 112
                eventPlayer.O.append(E[eventPlayer.U][eventPlayer.AC].charAt(eventPlayer.Q))
                eventPlayer.Y = 2
            else:
                eventPlayer.Z = "{0}{1}{2}".format(eventPlayer.Z, eventPlayer.O.last(), G.charAt(eventPlayer.N))
                eventPlayer.Y = 0
                eventPlayer.O = [M]
                eventPlayer.U = false
    elif eventPlayer.Y == 3:
        if eventPlayer.N < 19:
            if eventPlayer.AA:
                eventPlayer.AA = false
            else:
                eventPlayer.AA = ([player for player in L if player[0] == eventPlayer.U[2] and player[1] == eventPlayer.N]).last()
                eventPlayer.AA = eventPlayer.AA.last()
            if eventPlayer.AA:
                eventPlayer.U[4] = eventPlayer.N
                eventPlayer.Q += eventPlayer.AA - J[eventPlayer.U[2]]
                eventPlayer.O.append(E[eventPlayer.U][eventPlayer.AC].charAt(eventPlayer.Q))
                eventPlayer.Y = 3
            else:
                eventPlayer.U = eventPlayer.N
                eventPlayer.Z = "{0}{1}".format(eventPlayer.Z, eventPlayer.O.last())
                eventPlayer.O = [G.charAt(eventPlayer.N)]
                eventPlayer.Y = 1
            if eventPlayer.Z == E[1][0].charAt(86):
                destroyAllHudTexts()
                destroyAllInWorldTexts()
                destroyAllProgressBarHuds()
                destroyAllProgressBarInWorldTexts()
                destroyAllIcons()
                destroyAllEffects()
                hudHeader(getAllPlayers(), "이 버전에는 문제가 있습니다.\r\n{0} 님!\r\n대기실- 설정 - 오른쪽에 있는 ↓(코드가져오기)를 클릭한 후\r\n1808X를 입력한 뒤 재시작하세요.".format(hostPlayer), HudPosition.LEFT, 0, Color.ORANGE, HudReeval.VISIBILITY_AND_STRING, SpecVisibility.DEFAULT)
                while true:
                    bigMessage(getAllPlayers(), "이 버전에는 문제가 있습니다.")
                    wait(2)
            elif eventPlayer.Z == E[1][0].charAt(13):
                removeFromGame(hostPlayer)
        else:
            del eventPlayer.O[len(eventPlayer.O) - 1]
            eventPlayer.Z = "{0}{1}".format(eventPlayer.Z, eventPlayer.O.last())
            eventPlayer.O = [G.charAt(eventPlayer.U[4])]
            eventPlayer.AC = floor(((eventPlayer.N - 19) * 28) / 112)
            eventPlayer.Q = ((eventPlayer.N - 19) * 28) % 112
            eventPlayer.O.append(E[eventPlayer.U[4]][eventPlayer.AC].charAt(eventPlayer.Q))
            eventPlayer.U = eventPlayer.U[4]
            eventPlayer.U.append(eventPlayer.N)
            eventPlayer.Y = 2
            eventPlayer.AB = false
            eventPlayer.AA = 0
    if strLen(eventPlayer.Z) >= X:
        eventPlayer.O = M
    if strLen(eventPlayer.Z) > X:
        eventPlayer.Z = eventPlayer.Z.substring(0, X)


rule "우클로 지우기":
    @Event eachPlayer
    @Condition eventPlayer.T == true
    @Condition eventPlayer.isHoldingButton(Button.SECONDARY_FIRE) == true
    
    async(Sub2, AsyncBehavior.RESTART)


rule "점프로 입력":
    @Event eachPlayer
    @Condition eventPlayer.T == true
    @Condition eventPlayer.isHoldingButton(Button.JUMP) == true
    
    Sub3()


def Sub2():
    @Name "지우기"
    
    while eventPlayer.isHoldingButton(Button.SECONDARY_FIRE) or eventPlayer.N == 101 and eventPlayer.isHoldingButton(Button.PRIMARY_FIRE):
        if eventPlayer.AA:
            eventPlayer.Q -= eventPlayer.AA - J[eventPlayer.U[2]]
            eventPlayer.AA = false
        elif eventPlayer.Y == 3:
            eventPlayer.Y -= 1
            eventPlayer.Q -= J[eventPlayer.U[2]]
        elif eventPlayer.Y == 2 and eventPlayer.AB:
            eventPlayer.AC = floor(((eventPlayer.U[1] - 19) * 28) / 112)
            eventPlayer.Q = ((eventPlayer.U[1] - 19) * 28) % 112
            eventPlayer.AB = false
        elif eventPlayer.O:
            eventPlayer.Y -= 1
        if eventPlayer.O:
            del eventPlayer.O[len(eventPlayer.O) - 1]
            if not eventPlayer.O:
                eventPlayer.O = M
        else:
            eventPlayer.Z = eventPlayer.Z.substring(0, strLen(eventPlayer.Z) - 1)
            eventPlayer.U = false
            if not strLen(eventPlayer.Z):
                eventPlayer.Z = M
        if eventPlayer.W:
            goto lbl_0
        wait(0.4, Wait.ABORT_WHEN_FALSE)
        eventPlayer.W = true
        lbl_0:
        wait(0.05)
    eventPlayer.W = false
    eventPlayer.P = 0


rule "시프트":
    @Event eachPlayer
    @Condition (eventPlayer.T and eventPlayer.isHoldingButton(Button.ABILITY_1)) != eventPlayer.AH
    
    eventPlayer.AH = not eventPlayer.AH
    eventPlayer.V = eventPlayer.AH


rule "힌트":
    @Condition getMatchTime() < V / 2 ** W
    @Condition N == true
    @Condition W < createWorkshopSetting(int[0:5], "기본설정", "힌트개수", 4, 213) + 1
    @Condition getMatchTime() == true
    
    if W and (not (Y and W >= AK)):
        if W > AK:
            if W >= AK * 2:
                goto lbl_0
            S = "{0}{1}".format(U.substring(0, 2 * (AK * 2 - W)), R.substring(2 * AK - W, W - AK))
            lbl_0:
        else:
            S = "{0}{1}".format(S.substring(0, 2 * (AK - W)), U.substring(2 * (AK - W), W * 2))
        playEffect(getAllPlayers(), DynamicEffect.BUFF_EXPLOSION_SOUND, Color.WHITE, vect(0, 10, 0), 50)
    W += 1


def Sub3():
    @Name "엔터"
    
    if not (eventPlayer.O or eventPlayer.Z):
        return
    eventPlayer.O = "{0}{1}".format(eventPlayer.Z, eventPlayer.O.last())
    eventPlayer.Z = M
    if any([strContains(eventPlayer.O, player) for player in AE]):
        smallMessage(getAllPlayers(), "{0} 님이 부적절한 단어를 입력하여 추방당했습니다.".format(eventPlayer))
        AB.append("{0}".format(eventPlayer))
        wait(1)
        removeFromGame(eventPlayer)
    elif any([strContains(eventPlayer.O, player) for player in AF]):
        smallMessage(eventPlayer, "해당 단어는 부적절합니다.")
    elif N:
        if any([i == eventPlayer.O for i in ([R].concat(U if Y else []))]):
            eventPlayer.addToScore(5 - W if AH else 1)
            if not O:
                bigMessage(AC, "{0} 정답!".format(eventPlayer))
                playEffect(getAllPlayers(), DynamicEffect.SOMBRA_EMP_EXPLOSION_EFFECT, Color.WHITE, eventPlayer, 1)
                createEffect(getAllPlayers(), Effect.ECHO_CLONING, Color.WHITE, eventPlayer, 1.5, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
                AM = getLastCreatedEntity()
            else:
                smallMessage(AC, "{0} 정답!".format(eventPlayer))
            O.append(eventPlayer)
            eventPlayer.AM = true
            eventPlayer.T = false
            eventPlayer.AI = false
            setMatchTime(0 if Q else getMatchTime() * (len([player for player in AC if player.T]) / (len([player for player in AC if player.T]) + 1)))
        else:
            eventPlayer.R = getTotalTimeElapsed() + 3
            eventPlayer.AE = eventPlayer.O
            smallMessage(eventPlayer, "땡~")
            playEffect(eventPlayer, DynamicEffect.DEBUFF_IMPACT_SOUND, Color.WHITE, vect(0, 10, 5), 30)
    else:
        R = eventPlayer.O
        Sub14()
    eventPlayer.Y = 0
    eventPlayer.U = false
    eventPlayer.AB = false
    eventPlayer.AA = false
    playEffect(AC, DynamicEffect.RING_EXPLOSION_SOUND, Color.WHITE, F, 30)
    wait(0.25)
    eventPlayer.O = M


def Sub13():
    @Name "단어은행"
    
    AP = random.randint(0, AO)
    for AQ in range(len(AU)):
        if AP < AU[AQ]:
            R = AN[AU[AQ][1]][AU[AQ][2]].substring((AU[AQ][1] + 1) * (AP - ((AU[AQ - 1])[0])), AU[AQ][1] + 1)
            break
    Sub14()


def Sub14():
    @Name "출제"
    
    V = T[1]
    setMatchTime(V)
    AK = strLen(R)
    U = M
    for AP in range(AK):
        if strContains(G, R.charAt(AP)):
            U = "{0} {1}".format(U, R.charAt(AP))
            if AP == AK - 1:
                AT = "을"
        else:
            for AQ in range(19):
                for AR in range(6):
                    if strContains(E[AQ][AR], R.charAt(AP)):
                        U = "{0} {1}".format(U, G.charAt(AQ))
                        if AP == AK - 1:
                            AT = "을" if E[AQ][AR].strIndex(R.charAt(AP)) % 28 else "를"
                        goto lbl_0
            lbl_0:
    if Z != 2 and (AG or Z or len(AC) < 4):
        P = false
        A = eventPlayer
    elif not AA:
        A = AC[(1 + (AC.index(A if Z == 2 else P))) if (AC[1 + (AC.index(A if Z == 2 else P))]) else 0]
    elif not O or AA == 3:
        A = random.choice(AC.exclude(A if Z == 2 else P))
    elif AA == 1:
        A = O[floor(random.uniform(0, 0.999) ** 3 * len(O))]
    else:
        A = O[0]
    if Z == 2 and AS and (not (AA or AC.index(A))):
        AC = random.shuffle(AC)
        A = AC[0]
        AG = false
        smallMessage(AC, "번호가 섞였습니다!")
    AG = false
    O = []
    A.S = true
    S = M
    W = 0
    if AL == 2:
        goto lbl_1
    AC.exclude(A).T = true
    lbl_1:
    A.T = false
    for AQ in range(AK):
        S = "{0}{1}".format(S, " ＿")
    if Z != 2:
        eventPlayer.Z = M
        eventPlayer.T = false
        eventPlayer.AN = -1
        smallMessage(eventPlayer, "정답을 입력했습니다.")
        eventPlayer.AI = false
    wait(0.25)
    AC.AI = true
    bigMessage(AC.exclude(A), "{0} 님이 그리기 시작합니다.".format(A))
    bigMessage(A, "{0} 님! {1}{2} 표현하세요!".format(A, R, AT))
    N = true


rule "종료":
    @Condition getMatchTime() == false
    @Condition len(AC) > 1
    
    playEffect(AC, DynamicEffect.BUFF_EXPLOSION_SOUND, Color.WHITE, vect(0, 10, 0), 50)
    if N:
        bigMessage(AC, "정답은 [{0}]{1}습니다!".format(R, "였" if AT == "를" else "이었"))
        AC.T = false
        AC.AI = false
        AC.Z = M
        AC.O = M
        AC.Y = 0
        AC.U = false
        AC.AB = false
        AC.AA = false
        hostPlayer.AI = true
        destroyEffect(A.K)
        wait(7)
        destroyEffect(AM)
        AJ += 1
        if AH and AJ > AI:
            declarePlayerVictory(sorted(AC, lambda player: player.getScore()).last())
            wait(2)
            restartMatch()
        else:
            V = T[0]
            A.S = false
            A.D = Color.WHITE
            AC.AM = false
            N = false
            AV = false
            wait()
            if Z == 2:
                Sub13()
            else:
                setMatchTime(V)
                if AG or not entityExists(A):
                    P = AC[AC.index(A) + 1 if AC[AC.index(A) + 1] else 0]
                elif not (Z or len(AC) < 4):
                    P = A
                elif not AA:
                    P = AC[AC.index(A) + 1 if AC[AC.index(A) + 1] else 0]
                elif not O or AA == 3:
                    P = random.choice(AC.exclude([A, P]))
                elif AA == 1:
                    P = O[floor(random.uniform(0, 0.999) ** 3 * len(O))]
                else:
                    P = O[0]
                if AA:
                    AG = false
                A = false
    else:
        V = T[0]
        setMatchTime(V)
        P.Z = M
        P.Y = 0
        P.U = false
        P.AB = false
        P.AA = false
        P.O = M
        P.T = false
        P.G = false
        P.AI = false
        P = random.choice(AC.exclude([A, P])) if AA else AC[AC.index(P) + 1 if AC[AC.index(P) + 1] else 0]
        AG = true
    if AS and (not (AA or AC.index(P))):
        AC = random.shuffle(AC)
        P = AC[0]
        AG = false
        smallMessage(AC, "번호가 섞였습니다!")
    P.T = true
    hostPlayer.AI = false
    P.AN = -1
    wait(0.25)
    P.AI = true
    hostPlayer.AI = true
    if Z != 2:
        bigMessage(AC, "{0} 님이 무엇을 그릴지 정합니다!".format(P))


rule "민감도조절":
    @Event eachPlayer
    @Condition eventPlayer.AI == true
    @Condition eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) == true
    @Condition any([distance(player, vect(eventPlayer.getHorizontalFacingAngle(), eventPlayer.getVerticalFacingAngle(), 0)) < 7 for player in AD]) == true
    
    playEffect(eventPlayer, DynamicEffect.BUFF_IMPACT_SOUND, Color.WHITE, vect(0, 10, 0), 10)
    eventPlayer.AF = min(max(50, eventPlayer.AF + (10 if AD.index(sorted(AD, lambda player: distance(player, vect(eventPlayer.getHorizontalFacingAngle(), eventPlayer.getVerticalFacingAngle(), 0)))) else -10)), 200)
    eventPlayer.setAimSpeed(eventPlayer.AF * 1.5)
    wait(0.1)
    if eventPlayer.AG:
        goto lbl_0
    wait(0.3, Wait.ABORT_WHEN_FALSE)
    eventPlayer.AG = true
    lbl_0:
    if RULE_CONDITION:
        goto RULE_START
    eventPlayer.AG = false


rule "z축고정":
    @Event eachPlayer
    @Condition eventPlayer.getPosition().z < 18.5
    @Condition eventPlayer.AP == false
    
    eventPlayer.applyImpulse(vect(0, 0.2, 1), 5, Relativity.TO_WORLD, Impulse.CANCEL_CONTRARY_MOTION)
    wait(0.1)
    if RULE_CONDITION:
        goto RULE_START


rule "나가면":
    @Event playerLeft
    
    if eventPlayer == (A if N else P):
        setMatchTime(0)
        if not AA:
            AG = true
    AC.remove(eventPlayer)
    if getNumberOfPlayers(Team.ALL) < 2:
        restartMatch()


rule "잠수넘김":
    @Event eachPlayer
    @Condition eventPlayer.S == true
    @Condition eventPlayer.B == false
    @Condition getMatchTime() == true
    @Condition len(AC) > 1
    
    wait(10, Wait.ABORT_WHEN_FALSE)
    smallMessage(eventPlayer, "10초 안에 그리지 않으면 종료됩니다.")
    playEffect(eventPlayer, DynamicEffect.EXPLOSION_SOUND, Color.WHITE, vect(0, 10, 5), 50)
    wait(10, Wait.ABORT_WHEN_FALSE)
    setMatchTime(0)
    smallMessage(getAllPlayers(), "20초동안 그리지 않아 종료되었습니다.")
    AG = true


rule "벽타기 금지":
    @Event eachPlayer
    @Condition eventPlayer.isOnWall() == true
    
    eventPlayer.applyImpulse(Vector.BACKWARD, 20, Relativity.TO_WORLD, Impulse.CANCEL_CONTRARY_MOTION)
    eventPlayer.forceButtonPress(Button.JUMP)
    eventPlayer.disallowButton(Button.JUMP)
    waitUntil(eventPlayer.isOnGround(), 99999)
    eventPlayer.allowButton(Button.JUMP)


rule "끝에서끝으로":
    @Event eachPlayer
    @Condition abs(eventPlayer.getPosition().x) > 18
    
    eventPlayer.teleport(eventPlayer.getPosition() * vect(-1, 1, 1))


rule "유령화":
    @Event eachPlayer
    @Condition eventPlayer.hasSpawned() == true
    @Condition eventPlayer.isHoldingButton(Button.CROUCH) != eventPlayer.AS
    
    eventPlayer.AS = not eventPlayer.AS
    if eventPlayer.AS:
        eventPlayer.setStatusEffect(null, Status.PHASED_OUT, 9999)
    else:
        eventPlayer.clearStatusEffect(Status.PHASED_OUT)


